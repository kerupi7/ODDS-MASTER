<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ODDS MASTER</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        .animate-slide-in {
            animation: slideIn 0.3s ease-out;
        }
        
        /* Modern Calendar Styling */
        input[type="date"] {
            position: relative;
            background: white;
            cursor: pointer;
        }
        
        input[type="date"]::-webkit-calendar-picker-indicator {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: auto;
            height: auto;
            color: transparent;
            background: transparent;
            cursor: pointer;
        }
        
        input[type="date"]:hover {
            border-color: #10b981;
        }
        
        input[type="date"]:focus {
            outline: none;
            border-color: #10b981;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
        }
        
        /* Mobile input optimization */
        input[type="number"], select {
            font-size: 16px; /* Prevent zoom on iOS */
        }

        body {
            line-height: 1.6;
        }

        .pill-button {
            border-radius: 9999px;
            transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.06);
            min-width: 120px;
            height: 48px;
            padding: 0 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }

        .confidence-buttons {
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            gap: 12px;
        }

        .confidence-buttons .pill-button {
            flex: 1 1 0;
            min-width: 0;
        }

        .basis-buttons {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 12px;
        }

        .pill-button:hover {
            transform: translateY(-1px);
        }

        .pill-button:active {
            transform: scale(0.97);
        }

        .course-buttons-row {
            display: flex;
            flex-wrap: nowrap;
            gap: 8px;
            width: 100%;
        }

        .course-buttons-row .pill-button {
            flex: 1 1 0;
            min-width: 0;
        }

        .ticket-type-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .ticket-type-grid .pill-button {
            flex: 0 0 25%;
            min-width: 0;
        }

        .ticket-type-grid .pill-button:nth-child(n+5) {
            flex-basis: 33.333%;
        }

            .pill-button.pill-active {
                box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.35), 0 10px 18px rgba(0, 0, 0, 0.1);
            }

            .race-number-button {
                padding: 0;
            }

        .card-section {
            padding: 18px;
        }

        .section-title {
            line-height: 1.5;
            font-weight: 800;
        }

        .odds-header {
            width: 100vw;
            margin-left: calc(50% - 50vw);
            margin-right: calc(50% - 50vw);
            background-color: #047857;
            color: #ffffff;
            padding: 0;
            border-radius: 0;
        }

        .odds-header-inner {
            max-width: 768px;
            margin: 0 auto;
            padding: 16px 20px;
        }

        @media (max-width: 600px) {
            .mobile-shell {
                padding: 12px;
            }

            .odds-header-inner {
                padding: 14px 16px;
            }

            .app-main {
                padding: 0;
                gap: 18px;
            }

            .app-main > * + * {
                margin-top: 18px;
            }

            .card-section {
                padding: 22px 18px;
            }

            .section-title {
                margin-bottom: 10px;
                font-size: 1.1rem;
            }

            .pill-group {
                gap: 10px !important;
            }

            .pill-button {
                min-width: 120px;
                height: 48px;
                padding: 0.65rem 1.05rem;
                font-size: 16px;
                font-weight: 700;
                box-shadow: 0 8px 18px rgba(0, 0, 0, 0.08);
            }

            .pill-button.pill-active {
                box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.45), inset 0 0 0 1px rgba(16, 185, 129, 0.55);
            }

            .race-number-button {
                width: auto;
                height: auto;
                min-width: 0;
            }

            h1, h2, h3, h4 {
                line-height: 1.6;
            }

            p, label, span, button {
                line-height: 1.6;
            }

            .helper-text {
                font-size: 14px;
            }

            .voting-toggle button {
                min-height: 46px;
                font-size: 16px;
                font-weight: 700;
            }
        }

    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useEffect } = React;
        
        // --- Strategy Definitions ---
        const STRATEGIES = {
            matchup: { id: 'matchup', label: '相手', fullLabel: '相手関係', color: 'bg-red-100 text-red-800 border-red-300 focus:ring-red-500 font-bold' },
            data: { id: 'data', label: 'データ', fullLabel: 'データ', color: 'bg-blue-100 text-blue-800 border-blue-300 focus:ring-blue-500 font-bold' },
            odds: { id: 'odds', label: 'オッズ', fullLabel: 'オッズ', color: 'bg-yellow-100 text-yellow-800 border-yellow-300 focus:ring-yellow-500 font-bold' },
            intuition: { id: 'intuition', label: '直感', fullLabel: '直感', color: 'bg-gray-100 text-gray-800 border-gray-300 focus:ring-gray-500 font-bold' },
            paddock: { id: 'paddock', label: 'パドック', fullLabel: 'パドック', color: 'bg-emerald-100 text-emerald-800 border-emerald-300 focus:ring-emerald-500 font-bold' },
            pace: { id: 'pace', label: '展開', fullLabel: '展開', color: 'bg-indigo-100 text-indigo-800 border-indigo-300 focus:ring-indigo-500 font-bold' },
            other: { id: 'other', label: 'その他', fullLabel: 'その他', color: 'bg-slate-100 text-slate-800 border-slate-300 focus:ring-slate-500 font-bold' }
        };

        const REASON_TAGS = [
            { value: 'matchup', label: '相手' },
            { value: 'data', label: 'データ' },
            { value: 'intuition', label: '直感' },
            { value: 'odds', label: 'オッズ' },
            { value: 'paddock', label: 'パドック' },
            { value: 'pace', label: '展開' }
        ];

        const REASON_ORDER = ['matchup', 'data', 'intuition', 'odds', 'paddock', 'pace'];

        const ORDERED_REASON_TAGS = REASON_ORDER
            .map((value) => REASON_TAGS.find((tag) => tag.value === value))
            .filter(Boolean);

        // --- Confidence Definitions ---
        const CONFIDENCES = {
            'A': { id: 'A', label: '◎', fullLabel: '◎ 確勝', color: 'text-red-600 bg-red-50 border-red-200' },
            'B': { id: 'B', label: '◯', fullLabel: '◯ 自信有', color: 'text-blue-600 bg-blue-50 border-blue-200' },
            'C': { id: 'C', label: '▲', fullLabel: '▲ 一発', color: 'text-stone-700 bg-stone-100 border-stone-300' },
            'D': { id: 'D', label: '△', fullLabel: '△ 期待薄', color: 'text-gray-500 bg-gray-50 border-gray-200' }
        };

        const CONFIDENCE_LEVELS = [
            { value: 'A', label: '◎ 確勝' },
            { value: 'B', label: '◯ 自信有' },
            { value: 'C', label: '▲ 一発' },
            { value: 'D', label: '△ 期待薄' }
        ];

        const TICKET_TYPES = [
            { value: 'tansho', label: '単勝' },
            { value: 'fukusho', label: '複勝' },
            { value: 'wide', label: 'ワイド' },
            { value: 'umaren', label: '馬連' },
            { value: 'umatan', label: '馬単' },
            { value: 'sanrenpuku', label: '3連複' },
            { value: 'sanrentan', label: '3連単' }
        ];

        const TICKET_ORDER = [
            'tansho', 'fukusho', 'wide', 'umaren',
            'umatan', 'sanrenpuku', 'sanrentan'
        ];

        const ALL_COURSES = ['札幌', '函館', '福島', '新潟', '東京', '中山', '中京', '京都', '阪神', '小倉'];
        const MAX_RACES_PER_DAY = 12;
        const RACE_NUMBERS = Array.from({ length: MAX_RACES_PER_DAY }, (_, i) => i + 1);
        const TOP_RACE_NUMBERS = RACE_NUMBERS.slice(0, 6);
        const BOTTOM_RACE_NUMBERS = RACE_NUMBERS.slice(6);

        const getReasonLabel = (value) => {
            const item = REASON_TAGS.find((t) => t.value === value);
            if (item) return item.label;
            return STRATEGIES[value]?.label || '';
        };

        const HELP_SECTIONS = [
            {
                title: '平均オッズはなぜ危険か？資金加重の意味',
                body: '1点あたりの平均オッズだけを眺めると「全体でこのくらい当たればOK」という錯覚を生みます。\nしかし、実際には投入した金額の重みがかかるため、資金配分の偏りで期待値は大きくぶれます。\nODDS MASTERでは資金加重平均を常に意識し、「どこに資金の重心を置いているか」を可視化することで、勝負のブレを抑えます。'
            },
            {
                title: '危険ゾーンの本当の怖さ（勝率70%の壁）',
                body: '実質オッズが1.5倍未満の“危険ゾーン”は、当たり前のように当たる反面、少しのブレで即マイナスに転落します。\n勝率70%ラインを超えない限り、複利で資金を増やすのは難しく、むしろドローダウンを深める原因に。\nこのアプリは低オッズへの過剰投資を警告し、リスクリワードを再考させる仕組みを入れています。'
            },
            {
                title: '分散管理：一点買いと分散買いの境界線',
                body: '一点集中は「当たれば大きい」が、外したときに立て直しが難しくなります。\n一方で分散しすぎると勝率は上がっても回収率は下がり、手数料負けが顕在化します。\nODDS MASTERは想定的中率と資金配分を結びつけ、どこまで分散させるかを可視化することで、最適なリスクレンジを見つける手助けをします。'
            },
            {
                title: '期待値の二階建て：単体EVとポートフォリオEV',
                body: '単体馬券の期待値がプラスでも、組み合わせ方によっては全体EVがマイナスになります。\n逆に、単体では微妙でもポートフォリオでプラスになる構成も存在します。\nアプリでは「各点の期待値」と「全体の期待値」を別軸で表示し、両方を同時に最大化するデザインを採用しています。'
            },
            {
                title: 'ローテ・適性・仕上げを数字に落とし込む',
                body: '感覚的な強調ポイント（叩き2走目、距離短縮、輸送慣れなど）をスコアに変換し、オッズと掛け合わせて評価します。\nこれにより「なんとなく買い」という曖昧さを減らし、言語化された理由と数字で意思決定を記録します。'
            },
            {
                title: 'ペースとラップの読みをベット構成に反映',
                body: '想定ペースが速いのか遅いのかで軸とヒモの配置は変わります。\n逃げ・先行有利なら薄く広く、差し・追い込み決着なら厚く絞るなど、ラップシナリオに合わせて配分を変えるのがポイント。\nODDS MASTERでは買い目ごとの想定シナリオをメモし、結果と照合できるようになっています。'
            },
            {
                title: '枠順と馬場差をどう織り込むか',
                body: '同じ能力でも内外の差、当日の馬場バイアスで期待値は大きく動きます。\n馬場傾向を観測し、オッズにまだ反映されていないズレを拾うのが妙味の源泉。\nセクションごとに枠・馬場のメモ欄を用意し、あとから検証できる形で残すことを推奨しています。'
            },
            {
                title: 'データドリブン vs 勘：役割分担の設計',
                body: 'データは平均的な勝ち方を示し、直感は文脈的な例外を拾います。\nどちらか一方に寄りすぎると、過剰最適化かギャンブル的暴走のどちらかに。\n本アプリは「データ」「相手」「直感」のタグを明示し、判断軸を分解することで偏りをチェックできます。'
            },
            {
                title: '資金は口座、買い目は投資案件',
                body: '資金は銀行残高、買い目は案件として扱い、案件ごとにリターンとリスクを記録します。\n期待値の高い案件に厚く、低い案件にはリスク許容度に応じて薄く投資する発想で、資金曲線を安定化。\nバンクロール管理の履歴は資金推移として残り、次の勝負額の指針になります。'
            },
            {
                title: '逆算型のベットメイク（ゴールから組み立てる）',
                body: '「何円プラスにしたいか」から逆算して、必要なリターンと想定的中率を決めるのがODDS MASTER流。\n目標利益に対してどの買い目がボトルネックかを可視化し、過剰投資や過小投資を抑制します。'
            },
            {
                title: '三層防御のリスクヘッジ',
                body: '1. 本命ライン（軸）\n2. 打点ライン（相手）\n3. 保険ライン（押さえ）\nこの三層で勝負を組み立てると、当たり方のパターンが明確になり、どこで利益が出るか／守るかを整理できます。\nアプリではボックス・フォーメーションの切り替えで三層構造を再現しやすくしています。'
            },
            {
                title: '過去データの再学習と未来の仮説作り',
                body: '結果入力と回収率の推移は、単なる記録ではなく仮説検証の材料です。\n「どのパターンで外し、どのパターンで当たったか」を振り返ることで、次のレースでの仮説精度が上がります。\n履歴機能はそのためのログブックとして機能します。'
            },
            {
                title: 'メモは短く具体的に残す',
                body: '長文の反省よりも、次に使える短いトリガーワードを残すほうが実践的です。\n例："内伸び馬場＋先行有利→逃げ残り警戒" のように、条件と行動をセットで書くと再利用性が高まります。'
            },
            {
                title: '感情のノイズを切り離す仕組み',
                body: '連敗や連勝の後はベットサイズが無意識に変わりがちです。\n目標利益と許容損失を先に決めておくことで、感情ドリフトを抑止。\nODDS MASTERはバンクロールと目標設定を画面上部に固定し、常に現在地を確認できるようにしています。'
            }
        ];

        const HelpOverlay = ({ onClose }) => (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/40">
                <div className="bg-white max-w-4xl w-[90%] max-h-[90vh] rounded-2xl shadow-xl overflow-hidden flex flex-col">
                    <header className="px-6 py-4 border-b flex items-center justify-between bg-emerald-700 text-white">
                        <h2 className="text-base font-bold">ODDS MASTERの内容について</h2>
                        <button
                            className="text-sm px-3 py-1 border border-white/60 rounded-full hover:bg-white/10"
                            onClick={onClose}
                        >
                            閉じる
                        </button>
                    </header>
                    <div className="px-6 py-4 overflow-y-auto text-sm leading-relaxed bg-emerald-50/40">
                        <p className="text-xs text-gray-600 mb-4">
                            ODDS MASTERの裏側にある思想・ロジックをまとめたガイドです。時間があるときに、上から順番に読んでみてください。
                        </p>
                        <div className="space-y-4">
                            {HELP_SECTIONS.map((sec, idx) => (
                                <section
                                    key={idx}
                                    className="bg-white rounded-xl border border-emerald-100 px-4 py-3 shadow-sm"
                                >
                                    <h3 className="text-sm font-bold text-emerald-800 mb-1">
                                        {idx + 1}. {sec.title}
                                    </h3>
                                    <p className="text-xs text-gray-700 whitespace-pre-line">
                                        {sec.body}
                                    </p>
                                </section>
                            ))}
                        </div>
                    </div>
                </div>
            </div>
        );

        function formatDateYMD(date) {
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}-${m}-${d}`;
        }

        function formatDate(date) {
            return formatDateYMD(date);
        }

        function getBaseSaturday(today = new Date()) {
            const day = today.getDay(); // 0:日,1:月,2:火,3:水,4:木,5:金,6:土
            const diffToSaturday = (6 - day + 7) % 7;
            const base = new Date(today);
            base.setDate(today.getDate() + diffToSaturday);
            return base;
        }

        function getWeekendDatesForSchedule(schedule, today = new Date()) {
            const baseSat = getBaseSaturday(today);
            const labels = ['土', '日', '月'];
            const result = [];

            for (let i = 0; i < 3; i++) {
                const d = new Date(baseSat);
                d.setDate(baseSat.getDate() + i);
                const key = formatDateYMD(d);
                const courses = schedule[key];

                if (Array.isArray(courses) && courses.length > 0) {
                    result.push({
                        key,
                        date: d,
                        label: labels[i]
                    });
                }
            }

            return result;
        }

        function getInitialRaceDate() {
            const today = new Date();
            const day = today.getDay(); // 0=日曜, 1=月曜, 2=火曜...

            // 土・日・月は当日を使用
            if (day === 0 || day === 1 || day === 6) {
                return formatDateYMD(today);
            }

            // 火〜金は次の土曜日
            const nextSat = getBaseSaturday(today);
            return formatDateYMD(nextSat);
        }

        async function loadSchedule2026() {
            if (window.__schedule2026Cache) return window.__schedule2026Cache;
            try {
                const res = await fetch('./jra_schedule_2026.json');
                const data = await res.json();
                window.__schedule2026Cache = data;
                return data;
            } catch (e) {
                console.error('Failed to load schedule 2026', e);
                window.__schedule2026Cache = {};
                return {};
            }
        }

        function normalizeDateString(value) {
            if (!value) return null;
            if (/^\d{4}-\d{2}-\d{2}$/.test(value)) return value;
            if (/^\d{4}\/\d{2}\/\d{2}$/.test(value)) {
                return value.replaceAll('/', '-');
            }
            return value;
        }

        function getActiveCoursesForDate(schedule, dateString, allCourses) {
            const key = normalizeDateString(dateString);
            if (!schedule || !key) return allCourses;

            const courses = schedule[key];
            if (!Array.isArray(courses) || courses.length === 0) {
                return allCourses;
            }

            return allCourses.filter((c) => {
                const name = typeof c === 'string' ? c : (c.name || c.label || c.id);
                return courses.includes(name);
            });
        }

        // --- Icon System ---
        const IconBase = ({ children, size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const Icons = {
            Settings: (props) => <IconBase {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.35a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></IconBase>,
            Calculator: (props) => <IconBase {...props}><rect x="4" y="2" width="16" height="20" rx="2"/><line x1="8" x2="16" y1="6" y2="6"/><line x1="16" x2="16" y1="14" y2="18"/><path d="M16 10h.01"/><path d="M12 10h.01"/><path d="M8 10h.01"/><path d="M12 14h.01"/><path d="M8 14h.01"/><path d="M12 18h.01"/><path d="M8 18h.01"/></IconBase>,
            Trash2: (props) => <IconBase {...props}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></IconBase>,
            Save: (props) => <IconBase {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></IconBase>,
            Info: (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></IconBase>,
            RefreshCw: (props) => <IconBase {...props}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></IconBase>,
            Layers: (props) => <IconBase {...props}><path d="m12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83Z"/><path d="m22 17.65-9.17 4.16a2 2 0 0 1-1.66 0L2 17.65"/><path d="m22 12.65-9.17 4.16a2 2 0 0 1-1.66 0L2 12.65"/></IconBase>,
            GitMerge: (props) => <IconBase {...props}><circle cx="18" cy="18" r="3"/><circle cx="6" cy="6" r="3"/><path d="M6 21V9a9 9 0 0 0 9 9"/></IconBase>,
            PlusCircle: (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><path d="M8 12h8"/><path d="M12 8v8"/></IconBase>,
            X: (props) => <IconBase {...props}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></IconBase>,
            CheckSquare: (props) => <IconBase {...props}><polyline points="9 11 12 14 22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></IconBase>,
            Calendar: (props) => <IconBase {...props}><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" x2="16" y1="2" y2="6"/><line x1="8" x2="8" y1="2" y2="6"/><line x1="3" x2="21" y1="10" y2="10"/></IconBase>,
            MapPin: (props) => <IconBase {...props}><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"/><circle cx="12" cy="10" r="3"/></IconBase>,
            Flag: (props) => <IconBase {...props}><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"/><line x1="4" x2="4" y1="22" y2="15"/></IconBase>,
            FileText: (props) => <IconBase {...props}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="16" x2="8" y1="13" y2="13"/><line x1="16" x2="8" y1="17" y2="17"/><line x1="10" x2="8" y1="9" y2="9"/></IconBase>,
            History: (props) => <IconBase {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M12 7v5l4 2"/></IconBase>,
            ArrowLeft: (props) => <IconBase {...props}><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></IconBase>,
            CheckCircle: (props) => <IconBase {...props}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></IconBase>,
            AlertCircle: (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></IconBase>,
            BookOpen: (props) => <IconBase {...props}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></IconBase>,
            BarChart: (props) => <IconBase {...props}><line x1="12" x2="12" y1="20" y2="10"/><line x1="18" x2="18" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="16"/></IconBase>,
            TrendingUp: (props) => <IconBase {...props}><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"/><polyline points="17 6 23 6 23 12"/></IconBase>,
            ChevronDown: (props) => <IconBase {...props}><path d="m6 9 6 6 6-6"/></IconBase>,
            ChevronUp: (props) => <IconBase {...props}><path d="m18 15-6-6-6 6"/></IconBase>,
            Award: (props) => <IconBase {...props}><circle cx="12" cy="8" r="7"/><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"/></IconBase>,
            DollarSign: (props) => <IconBase {...props}><line x1="12" x2="12" y1="1" y2="23"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></IconBase>,
            Upload: (props) => <IconBase {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></IconBase>,
            Lightbulb: (props) => <IconBase {...props}><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-1 1.5-2.4 1.5-3.8 0-3.3-2.7-6-6-6 0 3.3-2.7 6-6 6-1.5 0-2.5-1.4-3.8-1.5-2.5 .8-1 1.3 1.7 1.5 2.5"/><line x1="9" y1="18" x2="15" y2="18"/><line x1="10" y1="22" x2="14" y2="22"/></IconBase>,
            Ban: (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><line x1="4.93" x2="19.07" y1="4.93" y2="19.07"/></IconBase>,
            Tag: (props) => <IconBase {...props}><path d="M12 2H2v10l9.29 9.29c.94.94 2.48.94 3.42 0l6.58-6.58c.94-.94.94-2.48 0-3.42L12 2Z"/><path d="M7 7h.01"/></IconBase>,
            Star: (props) => <IconBase {...props}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></IconBase>,
            List: (props) => <IconBase {...props}><line x1="8" x2="21" y1="6" y2="6"/><line x1="8" x2="21" y1="12" y2="12"/><line x1="8" x2="21" y1="18" y2="18"/><line x1="3" x2="3.01" y1="6" y2="6"/><line x1="3" x2="3.01" y1="12" y2="12"/><line x1="3" x2="3.01" y1="18" y2="18"/></IconBase>,
            Activity: (props) => <IconBase {...props}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></IconBase>,
            Menu: (props) => (
                <IconBase {...props}>
                    <line x1="4" x2="20" y1="7" y2="7" />
                    <line x1="4" x2="20" y1="12" y2="12" />
                    <line x1="4" x2="20" y1="17" y2="17" />
                </IconBase>
            ),
        };

        const getZoneFromEffectiveOdds = (effectiveOdds) => {
            if (effectiveOdds == null) return null;
            if (effectiveOdds < 1.5) return 'danger';
            if (effectiveOdds < 3.0) return 'fair';
            return 'attack';
        };

        function calculateZoneStats(records) {
            const initial = {
                danger: { label: '危険ゾーン', range: '〜1.5倍', count: 0, winCount: 0, totalStake: 0, totalReturn: 0 },
                fair: { label: '適正ゾーン', range: '1.5〜2.9倍', count: 0, winCount: 0, totalStake: 0, totalReturn: 0 },
                attack: { label: '攻撃ゾーン', range: '3.0倍〜', count: 0, winCount: 0, totalStake: 0, totalReturn: 0 }
            };

            const stats = (records || []).reduce((acc, rec) => {
                const zone = getZoneFromEffectiveOdds(rec.effectiveOdds);
                if (!zone || !acc[zone]) return acc;

                const stake = rec.totalInvested || rec.totalStake || 0;
                const ret = rec.totalReturn != null
                    ? rec.totalReturn
                    : (stake + (rec.netProfit != null ? rec.netProfit : (rec.profit || 0)));
                const isWin = ret > stake;

                acc[zone].count += 1;
                acc[zone].totalStake += stake;
                acc[zone].totalReturn += ret;
                if (isWin) acc[zone].winCount += 1;

                return acc;
            }, initial);

            Object.values(stats).forEach((z) => {
                z.hitRate = z.count > 0 ? (z.winCount / z.count) * 100 : 0;
                z.roi = z.totalStake > 0 ? (z.totalReturn / z.totalStake) * 100 : 0;
            });

            return stats;
        }

        // Effective Odds Calculator
        function calculateEffectiveOdds(bets) {
            const safeBets = Array.isArray(bets) ? bets : [];

            const totalAmount = safeBets.reduce((sum, bet) => sum + (Number(bet.amount) || 0), 0);
            const weightedOdds = safeBets.reduce((sum, bet) => sum + ((Number(bet.amount) || 0) * (Number(bet.odds) || 0)), 0);

            const effectiveOddsBase = totalAmount > 0 ? weightedOdds / totalAmount : 0;
            const effectiveOdds = Number.isFinite(effectiveOddsBase) ? effectiveOddsBase : 0;

            const zone = getZoneFromEffectiveOdds(effectiveOdds) || 'fair';
            let zoneLabel = '適正ゾーン（1.5〜2.9倍）';
            let zoneDescription = '勝率40〜60%で資金が増えやすい、最も現実的で安定した領域です。ここを主戦場にするのが理想です。';

            if (zone === 'danger') {
                zoneLabel = '危険ゾーン（1.5倍未満）';
                zoneDescription = '勝率70%以上を維持しないと増えない、極めてシビアな領域です。基本的には見送り推奨です。';
            } else if (zone === 'attack') {
                zoneLabel = '攻撃ゾーン（3.0倍以上）';
                zoneDescription = '一撃のリターンは大きいですが連敗リスクも高い領域です。「ボーナスゲーム」として限定的に使うのが安全です。';
            }

            return {
                effectiveOdds,
                zone,
                zoneLabel,
                zoneDescription,
                totalAmount
            };
        }

        const mapEffectiveOddsToPercent = (effectiveOdds) => {
            const value = Number(effectiveOdds);
            if (!Number.isFinite(value) || value <= 0) return 0;

            if (value < 1.5) {
                const ratio = Math.max(0, value) / 1.5;
                return Math.min(ratio * 33, 33);
            }

            if (value < 3.0) {
                const ratio = (value - 1.5) / (3.0 - 1.5);
                return 33 + Math.min(Math.max(ratio, 0), 1) * 33;
            }

            const capped = Math.min(value, 6.0);
            const ratio = (capped - 3.0) / (6.0 - 3.0);
            return 66 + Math.min(Math.max(ratio, 0), 1) * 34;
        };

        const RiskZoneMeter = ({ effectiveOdds, zone }) => {
            const pointerLeft = mapEffectiveOddsToPercent(effectiveOdds);

            const zoneAccent = {
                danger: 'border-red-200 shadow-inner shadow-red-100/70',
                fair: 'border-emerald-200 shadow-inner shadow-emerald-100/70',
                normal: 'border-emerald-200 shadow-inner shadow-emerald-100/70',
                attack: 'border-yellow-200 shadow-inner shadow-yellow-100/70'
            }[zone] || 'border-gray-200 shadow-inner';

            const pointerAccent = {
                danger: 'border-b-red-500 text-red-700 border-red-200',
                fair: 'border-b-emerald-600 text-emerald-700 border-emerald-200',
                normal: 'border-b-emerald-600 text-emerald-700 border-emerald-200',
                attack: 'border-b-yellow-500 text-amber-700 border-yellow-200'
            }[zone] || 'border-b-gray-700 text-gray-700 border-gray-200';

            const pointerLabel = Number.isFinite(effectiveOdds) && effectiveOdds > 0
                ? `${effectiveOdds.toFixed(2)}倍`
                : '計測外';

            return (
                <div className="mt-4">
                    <div className="flex justify-between text-[10px] text-gray-500 mb-1">
                        <span>リスクゾーンメーター</span>
                        <span>※ 実質オッズがどこにあるかを示します</span>
                    </div>
                    <div className={`relative h-3 rounded-full overflow-hidden flex text-[10px] border ${zoneAccent}`}>
                        <div className="flex-1 bg-red-100" />
                        <div className="flex-1 bg-emerald-100" />
                        <div className="flex-1 bg-yellow-100" />
                        <div
                            className="absolute -top-4 transition-all duration-200 flex flex-col items-center"
                            style={{ left: `${pointerLeft}%`, transform: 'translateX(-50%)' }}
                        >
                            <span className={`px-2 py-0.5 rounded-full text-[10px] font-semibold bg-white shadow-sm border ${pointerAccent}`}>
                                {pointerLabel}
                            </span>
                            <div className={`w-0 h-0 border-l-[5px] border-r-[5px] border-b-[7px] border-transparent ${pointerAccent}`} />
                        </div>
                    </div>
                    <div className="flex justify-between mt-1 text-[10px] text-gray-600">
                        <span className="text-red-600">危険ゾーン 〜1.5倍</span>
                        <span className="text-emerald-700">適正ゾーン 1.5〜2.9倍</span>
                        <span className="text-yellow-700">攻撃ゾーン 3.0倍〜</span>
                    </div>
                </div>
            );
        };

        const EffectiveOddsPanel = ({ bets }) => {
            const info = useMemo(() => calculateEffectiveOdds(bets || []), [bets]);

            if (!bets || bets.length === 0 || info.totalAmount === 0) return null;

            const { effectiveOdds, zone, zoneLabel, zoneDescription } = info;

            const zoneStyle = {
                danger: 'bg-red-50 border-red-200 text-red-700',
                fair: 'bg-emerald-50 border-emerald-200 text-emerald-700',
                normal: 'bg-emerald-50 border-emerald-200 text-emerald-700',
                attack: 'bg-yellow-50 border-yellow-200 text-yellow-700'
            }[zone] || 'bg-gray-50 border-gray-200 text-gray-700';

            return (
                <div className={`mt-4 p-4 rounded-xl border ${zoneStyle} shadow-sm`}>
                    <h3 className="text-xs font-bold uppercase flex items-center gap-2 mb-2">
                        <Icons.Calculator size={14} />
                        実質オッズとリスクゾーン
                    </h3>
                    <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
                        <div>
                            <div className="text-2xl font-extrabold">
                                {effectiveOdds.toFixed(2)}<span className="text-base font-semibold ml-1">倍</span>
                            </div>
                            <p className="text-xs text-gray-600 mt-1">
                                資金配分を考慮した「あなたの勝負の重心」です。
                            </p>
                        </div>
                        <div className="text-right">
                            <span className="inline-flex px-3 py-1 rounded-full text-[11px] font-bold bg-white/70 border border-current">
                                {zoneLabel}
                            </span>
                            <p className="text-[11px] mt-1">
                                {zoneDescription}
                            </p>
                        </div>
                    </div>
                    <RiskZoneMeter effectiveOdds={effectiveOdds} zone={zone} />
                </div>
            );
        };

        function WhatIfResultPanel({ result }) {
            if (!result) return null;

            const isDanger = result.minProfit < 0;
            const totalCount = result.details?.length || 0;
            const hasLosers = (result.losersCount || 0) > 0;

            return (
                <div className={`mt-3 p-3 rounded-lg text-xs border ${
                    isDanger ? 'bg-red-50 border-red-200 text-red-800' : 'bg-emerald-50 border-emerald-200 text-emerald-800'
                }`}>
                    <div className="font-bold mb-1 flex items-center gap-1">
                        <Icons.Activity size={13} />
                        オッズ変動シミュレーション結果（-{result.rate}%）
                    </div>

                    <p className="text-[11px] mb-2">
                        {hasLosers
                            ? `${totalCount}点中 ${result.losersCount}点が、オッズが下がると勝ってもマイナス（トリガミ候補）です。`
                            : `${totalCount}点すべて、オッズが下がっても当たればプラス圏です。`}
                    </p>

                    <div className="flex justify-between">
                        <span>最悪利益（当たり時）</span>
                        <span className="font-mono">{result.minProfit.toLocaleString()}円</span>
                    </div>

                    <div className="flex justify-between mt-1">
                        <span>最大利益（当たり時）</span>
                        <span className="font-mono">{result.maxProfit.toLocaleString()}円</span>
                    </div>

                    {result.details && result.details.length > 0 && (
                        <table className="mt-2 w-full text-[11px]">
                            <thead className="text-gray-500">
                                <tr>
                                    <th className="text-left py-1">買い目</th>
                                    <th className="text-right py-1">変動後オッズ</th>
                                    <th className="text-right py-1">投資額</th>
                                    <th className="text-right py-1">当たり時損益</th>
                                </tr>
                            </thead>
                            <tbody>
                                {result.details.map((d) => {
                                    const isLoss = d.profit < 0;
                                    const isGain = d.profit > 0;
                                    return (
                                        <tr key={d.id} className={isLoss ? 'text-red-700' : isGain ? 'text-emerald-700' : 'text-gray-700'}>
                                            <td className="py-1 pr-2">{d.label}</td>
                                            <td className="py-1 text-right">{d.simulatedOdds.toFixed(2)}倍</td>
                                            <td className="py-1 text-right">{d.amount.toLocaleString()}円</td>
                                            <td className="py-1 text-right">
                                                {d.profit >= 0 ? '+' : ''}
                                                {d.profit.toLocaleString()}円
                                            </td>
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                    )}
                </div>
            );
        }

        // Place (Race Track) Accordion Component
        const PlaceAccordion = ({ place, courses }) => {
            const [isOpen, setIsOpen] = React.useState(false);
            const courseCount = Object.keys(courses).length;

            return (
                <div className="bg-white rounded-lg shadow border border-gray-200 overflow-hidden">
                    <button
                        onClick={() => setIsOpen(!isOpen)}
                        className="w-full p-4 flex items-center justify-between hover:bg-gray-50 transition-colors text-left"
                    >
                        <div className="flex items-center gap-3">
                            <div className={`p-2 rounded-full ${isOpen ? 'bg-emerald-100 text-emerald-700' : 'bg-gray-100 text-gray-500'}`}>
                                <Icons.MapPin size={20} />
                            </div>
                            <div>
                                <h3 className="text-lg font-bold text-gray-800">{place}</h3>
                                <p className="text-xs text-gray-500">{courseCount}コース</p>
                            </div>
                        </div>
                        <div>
                            {isOpen ? <Icons.ChevronUp size={24} className="text-gray-400" /> : <Icons.ChevronDown size={24} className="text-gray-400" />}
                        </div>
                    </button>

                    {isOpen && (
                        <div className="p-4 pt-0 border-t border-gray-100 bg-gray-50">
                            <div className="space-y-3 mt-3">
                                {Object.entries(courses).map(([courseName, data]) => (
                                    <CourseAccordion key={place + '-' + courseName} courseName={courseName} data={data} />
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Date Accordion Component for Results
        const DateAccordion = ({ date, results, loadFromResult, bankrollHistory, deleteBankrollRecord }) => {
            const [isOpen, setIsOpen] = React.useState(false);
            const raceCount = results.length;
            const totalProfit = results.reduce((sum, r) => sum + r.profit, 0);

            // その日付のbankroll記録を探す
            const bankrollRecord = bankrollHistory.find(record => record.date === date);

            return (
                <div className="bg-white rounded-lg shadow border border-gray-200 overflow-hidden">
                    <button
                        onClick={() => setIsOpen(!isOpen)}
                        className="w-full p-4 flex items-center justify-between hover:bg-gray-50 transition-colors text-left"
                    >
                        <div className="flex items-center gap-3">
                            <div className={`p-2 rounded-full ${isOpen ? 'bg-blue-100 text-blue-700' : 'bg-gray-100 text-gray-500'}`}>
                                <Icons.Calendar size={20} />
                            </div>
                            <div>
                                <h3 className="text-lg font-bold text-gray-800">{date}</h3>
                                <p className="text-xs text-gray-500">{raceCount}レース</p>
                            </div>
                        </div>
                        <div className="flex items-center gap-3">
                            <div className={`font-bold ${totalProfit >= 0 ? 'text-emerald-600' : 'text-red-600'}`}>
                                {totalProfit >= 0 ? '+' : ''}{totalProfit.toLocaleString()}円
                            </div>
                            <div>
                                {isOpen ? <Icons.ChevronUp size={24} className="text-gray-400" /> : <Icons.ChevronDown size={24} className="text-gray-400" />}
                            </div>
                        </div>
                    </button>

                    {isOpen && (
                        <div className="p-4 pt-0 border-t border-gray-100 bg-gray-50">
                            {/* Bankroll記録を表示 */}
                            {bankrollRecord && (
                                <div className="bg-blue-50 border border-blue-200 p-3 rounded-lg mb-3 mt-3">
                                    <div className="flex items-center justify-between">
                                        <div className="flex items-center gap-2">
                                            <Icons.TrendingUp size={16} className="text-blue-600" />
                                            <span className="text-sm font-bold text-blue-900">Today's Bankroll 記録</span>
                                            {bankrollRecord.isGoal && <span className="bg-yellow-100 text-yellow-800 px-2 py-0.5 rounded text-xs">達成</span>}
                                        </div>
                                        <button
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                deleteBankrollRecord(bankrollRecord.id);
                                            }}
                                            className="text-gray-400 hover:text-red-500 p-1"
                                        >
                                            <Icons.Trash2 size={14} />
                                        </button>
                                    </div>
                                    <div className="grid grid-cols-2 gap-2 mt-2 text-xs">
                                        <div className="bg-white p-2 rounded">
                                            <div className="text-gray-500">開始資金</div>
                                            <div className="font-bold text-gray-700">{bankrollRecord.start.toLocaleString()}円</div>
                                        </div>
                                        <div className="bg-white p-2 rounded">
                                            <div className="text-gray-500">終了資金</div>
                                            <div className="font-bold text-gray-700">{bankrollRecord.end.toLocaleString()}円</div>
                                        </div>
                                        <div className="bg-white p-2 rounded">
                                            <div className="text-gray-500">目標</div>
                                            <div className="font-bold text-gray-700">{bankrollRecord.goal.toLocaleString()}円</div>
                                        </div>
                                        <div className={`p-2 rounded ${bankrollRecord.profit >= 0 ? 'bg-emerald-50' : 'bg-red-50'}`}>
                                            <div className="text-gray-500">収支</div>
                                            <div className={`font-bold ${bankrollRecord.profit >= 0 ? 'text-emerald-600' : 'text-red-600'}`}>
                                                {bankrollRecord.profit >= 0 ? '+' : ''}{bankrollRecord.profit.toLocaleString()}円 ({bankrollRecord.percent}%)
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}

                            <div className="space-y-3 mt-3">
                                {results.map((result) => {
                                    const strategy = STRATEGIES[result.strategy] || STRATEGIES.data;
                                    const confidence = CONFIDENCES[result.confidence] || CONFIDENCES.A;

                                    return (
                                        <div key={result.id} className={`border-l-4 rounded-lg p-4 ${result.profit >= 0 ? 'border-emerald-500 bg-emerald-50' : 'border-red-500 bg-red-50'}`}>
                                            <div className="flex justify-between items-start mb-3">
                                                <div>
                                                    <div className="flex items-center gap-2 mb-1">
                                                        <span className="font-bold text-lg text-gray-800">{result.place} {result.raceNum}R</span>
                                                        <span className={`text-[10px] px-1.5 py-0.5 rounded border ${strategy.color.replace('focus:ring-', '')}`}>
                                                            {getReasonLabel(strategy.id)}
                                                        </span>
                                                        <span className={`text-[10px] px-1.5 py-0.5 rounded border ${confidence.color.replace('bg-', 'bg-opacity-10 bg-').replace('text-', 'text-opacity-90 text-')}`}>
                                                            {confidence.label}
                                                        </span>
                                                    </div>
                                                </div>
                                                <div className="text-right">
                                                    <div className={`font-bold text-xl ${result.profit >= 0 ? 'text-emerald-600' : 'text-red-600'}`}>
                                                        {result.profit >= 0 ? '+' : ''}{result.profit.toLocaleString()}円
                                                    </div>
                                                    <div className="text-xs text-gray-600">
                                                        的中 {result.winCount}/{result.totalBets}点
                                                    </div>
                                                </div>
                                            </div>

                                            <div className="grid grid-cols-3 gap-2 text-xs mb-3 bg-white p-2 rounded">
                                                <div>
                                                    <span className="text-gray-500">投資:</span>
                                                    <span className="font-bold ml-1">{result.totalInvested.toLocaleString()}円</span>
                                                </div>
                                                <div>
                                                    <span className="text-gray-500">回収:</span>
                                                    <span className="font-bold ml-1">{result.totalReturn.toLocaleString()}円</span>
                                                </div>
                                                <div>
                                                    <span className="text-gray-500">回収率:</span>
                                                    <span className="font-bold ml-1">{result.totalInvested > 0 ? ((result.totalReturn / result.totalInvested) * 100).toFixed(1) : 0}%</span>
                                                </div>
                                            </div>

                                            <div className="text-xs bg-white p-2 rounded mb-2">
                                                <span className="text-gray-600">結果: </span>
                                                <span className="font-bold">
                                                    1着-{result.result.first} / 2着-{result.result.second} / 3着-{result.result.third}
                                                </span>
                                            </div>

                                            {result.note && (
                                                <div className="text-xs bg-white p-2 rounded mb-2">
                                                    <span className="text-gray-600">メモ: </span>
                                                    <span>{result.note}</span>
                                                </div>
                                            )}

                                            {result.reflectionNote && (
                                                <div className="text-xs bg-yellow-50 border border-yellow-200 p-3 rounded mb-2">
                                                    <div className="flex items-center gap-1 text-yellow-700 font-semibold mb-1">
                                                        <Icons.FileText size={14} />
                                                        <span>反省ノート</span>
                                                    </div>
                                                    <div className="text-gray-700 whitespace-pre-wrap">{result.reflectionNote}</div>
                                                </div>
                                            )}

                                            <button
                                                onClick={() => loadFromResult(result)}
                                                className="w-full bg-white border border-emerald-600 text-emerald-600 py-2 rounded text-sm font-bold hover:bg-emerald-50 flex items-center justify-center gap-2"
                                            >
                                                <Icons.RefreshCw size={14} />
                                                買い目を確認・編集
                                            </button>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const ZoneStatsPanel = ({ records }) => {
            const stats = calculateZoneStats(records);
            const zones = ['danger', 'fair', 'attack'];

            return (
                <div className="mt-4 p-4 bg-white rounded-xl border border-gray-200">
                    <h3 className="text-sm font-bold mb-2">ゾーン別成績（実質オッズベース）</h3>
                    <p className="text-xs text-gray-500 mb-3">
                        危険ゾーン／適正ゾーン／攻撃ゾーンごとの的中率と回収率です。
                    </p>
                    <table className="w-full text-xs">
                        <thead className="text-gray-500 border-b">
                            <tr>
                                <th className="text-left py-1">ゾーン</th>
                                <th className="text-center py-1">範囲</th>
                                <th className="text-right py-1">日数</th>
                                <th className="text-right py-1">的中率</th>
                                <th className="text-right py-1">回収率</th>
                            </tr>
                        </thead>
                        <tbody>
                            {zones.map((key) => {
                                const z = stats[key];
                                return (
                                    <tr key={key} className="border-b last:border-b-0">
                                        <td className="py-1">{z.label}</td>
                                        <td className="py-1 text-center">{z.range}</td>
                                        <td className="py-1 text-right">{z.count}</td>
                                        <td className="py-1 text-right">
                                            {z.count > 0 ? `${z.hitRate.toFixed(1)}%` : '-'}
                                        </td>
                                        <td className="py-1 text-right">
                                            {z.totalStake > 0 ? `${z.roi.toFixed(1)}%` : '-'}
                                        </td>
                                    </tr>
                                );
                            })}
                        </tbody>
                    </table>
                </div>
            );
        };

        // Course Accordion Component
        const CourseAccordion = ({ courseName, data }) => {
            const [isOpen, setIsOpen] = React.useState(false);
            
            return (
                <div className="bg-white rounded-lg shadow border border-gray-100 overflow-hidden">
                    <button
                        onClick={() => setIsOpen(!isOpen)}
                        className="w-full p-4 flex items-center justify-between hover:bg-gray-50 transition-colors text-left"
                    >
                        <div className="flex items-center gap-3">
                            <div className={`p-2 rounded-full ${isOpen ? 'bg-emerald-100 text-emerald-700' : 'bg-gray-100 text-gray-500'}`}>
                                <Icons.Flag size={18} />
                            </div>
                            <div>
                                <h4 className="text-sm font-bold text-gray-800">{courseName}</h4>
                                <p className="text-xs text-gray-500 truncate max-w-[200px]">{data.overview}</p>
                            </div>
                        </div>
                        <div>
                            {isOpen ? <Icons.ChevronUp size={20} className="text-gray-400" /> : <Icons.ChevronDown size={20} className="text-gray-400" />}
                        </div>
                    </button>

                    {isOpen && (
                        <div className="p-4 pt-0 border-t border-gray-100 bg-gray-50/50">
                            <div className="space-y-4 mt-3">
                                
                                <div className="bg-white p-3 rounded border border-gray-200">
                                    <h5 className="text-xs font-bold text-gray-500 mb-2 uppercase flex items-center gap-1">
                                        <Icons.Info size={12} /> コース特徴
                                    </h5>
                                    <ul className="text-sm text-gray-700 space-y-1 list-disc list-inside">
                                        {data.features.map((f, i) => <li key={i}>{f}</li>)}
                                    </ul>
                                </div>

                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                                    <div className="bg-white p-3 rounded border border-gray-200">
                                        <h5 className="text-xs font-bold text-gray-500 mb-2 uppercase">脚質傾向</h5>
                                        <div className="space-y-2 text-sm">
                                            {Object.entries(data.style).map(([key, val]) => {
                                                const label = { escape: '逃げ', lead: '先行', chase: '差し', late: '追込' }[key];
                                                return (
                                                    <div key={key} className="flex justify-between border-b border-gray-100 pb-1 last:border-0">
                                                        <span className="font-semibold text-gray-600">{label}</span>
                                                        <div className="text-right">
                                                            {val.return && <span className="text-emerald-600 font-bold mr-2">回{val.return}</span>}
                                                            {val.note && <span className="text-xs text-gray-400">{val.note}</span>}
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>

                                    <div className="bg-white p-3 rounded border border-gray-200">
                                        <h5 className="text-xs font-bold text-gray-500 mb-2 uppercase">枠順傾向</h5>
                                        <div className="space-y-2 text-sm">
                                            <div className="text-emerald-700"><span className="font-bold">◎</span> {data.frame.good}</div>
                                            <div className="text-orange-600"><span className="font-bold">▲</span> {data.frame.bad}</div>
                                            <div className="text-red-600"><span className="font-bold">✕</span> {data.frame.worst}</div>
                                        </div>
                                    </div>
                                </div>

                                <div className="bg-white p-3 rounded border border-gray-200">
                                    <h5 className="text-xs font-bold text-gray-500 mb-2 uppercase">血統傾向</h5>
                                    <div className="flex flex-wrap gap-2 mb-2">
                                        <span className="text-xs font-bold text-emerald-600 bg-emerald-50 px-2 py-1 rounded">好走:</span>
                                        {data.blood.good.map((b, i) => <span key={i} className="text-xs bg-gray-100 px-2 py-1 rounded text-gray-700">{b}</span>)}
                                    </div>
                                    {data.blood.bad.length > 0 && (
                                        <div className="flex flex-wrap gap-2">
                                            <span className="text-xs font-bold text-red-500 bg-red-50 px-2 py-1 rounded">不振:</span>
                                            {data.blood.bad.map((b, i) => <span key={i} className="text-xs bg-gray-100 px-2 py-1 rounded text-gray-700">{b}</span>)}
                                        </div>
                                    )}
                                </div>

                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                                    <div className="bg-blue-50 p-3 rounded border border-blue-100">
                                        <h5 className="text-xs font-bold text-blue-700 mb-1 flex items-center gap-1"><Icons.CheckCircle size={12}/> 軸のポイント</h5>
                                        <ul className="text-xs text-blue-900 space-y-1">
                                            {data.axis.map((t, i) => <li key={i}>・{t}</li>)}
                                        </ul>
                                    </div>
                                    <div className="bg-yellow-50 p-3 rounded border border-yellow-100">
                                        <h5 className="text-xs font-bold text-yellow-700 mb-1 flex items-center gap-1"><Icons.AlertCircle size={12}/> 穴のポイント</h5>
                                        <ul className="text-xs text-yellow-900 space-y-1">
                                            {data.hole.map((t, i) => <li key={i}>・{t}</li>)}
                                        </ul>
                                    </div>
                                </div>

                                {data.tips && data.tips.length > 0 && (
                                    <div className="bg-emerald-50 p-3 rounded border border-emerald-100">
                                        <h5 className="text-xs font-bold text-emerald-700 mb-1 flex items-center gap-1">
                                            <Icons.Lightbulb size={12}/> 攻略のヒント (Tips)
                                        </h5>
                                        <ul className="text-xs text-emerald-900 space-y-1">
                                            {data.tips.map((t, i) => <li key={i}>・{t}</li>)}
                                        </ul>
                                    </div>
                                )}

                                {data.avoid && data.avoid.length > 0 && (
                                    <div className="bg-red-50 p-3 rounded border border-red-100">
                                        <h5 className="text-xs font-bold text-red-700 mb-1 flex items-center gap-1">
                                            <Icons.Ban size={12}/> 消しのポイント (Avoid)
                                        </h5>
                                        <ul className="text-xs text-red-900 space-y-1">
                                            {data.avoid.map((t, i) => <li key={i}>・{t}</li>)}
                                        </ul>
                                    </div>
                                )}

                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Location Accordion Component
        const LocationAccordion = ({ place, courses }) => {
            const [isOpen, setIsOpen] = useState(false);

            return (
                <div className="border border-emerald-200 rounded-lg overflow-hidden shadow-sm bg-white mb-3">
                    <button
                        onClick={() => setIsOpen(!isOpen)}
                        className={`w-full p-4 flex items-center justify-between transition-colors ${isOpen ? 'bg-emerald-50' : 'bg-white hover:bg-gray-50'}`}
                    >
                        <div className="flex items-center gap-3">
                            <div className={`p-2 rounded-full ${isOpen ? 'bg-emerald-500 text-white' : 'bg-gray-100 text-gray-500'}`}>
                                <Icons.MapPin size={20} />
                            </div>
                            <div className="text-left">
                                <h3 className="text-lg font-bold text-gray-800">{place}</h3>
                                <span className="text-xs text-gray-500">{Object.keys(courses).length}コース</span>
                            </div>
                        </div>
                        {isOpen ? <Icons.ChevronUp size={24} className="text-gray-400" /> : <Icons.ChevronDown size={24} className="text-gray-400" />}
                    </button>
                    
                    {isOpen && (
                        <div className="p-4 bg-gray-50 space-y-3 border-t border-gray-100">
                            {Object.entries(courses).map(([courseName, data]) => (
                                <CourseAccordion key={place + '-' + courseName} courseName={courseName} data={data} />
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const HorseRacingOddsManager = () => {
            // State Definitions
            const [currentView, setCurrentView] = useState('calculator');
            const [menuOpen, setMenuOpen] = useState(false);
            const [showHelp, setShowHelp] = useState(false);
            
            // 編集中の履歴IDを管理（新規作成時はnull）
            const [editingId, setEditingId] = useState(null);

            // 編集中の結果IDを管理（新規作成時はnull）
            const [editingResultId, setEditingResultId] = useState(null);

            // 編集中の結果データを保持
            const [editingResultData, setEditingResultData] = useState(null);

            // --- Bankroll Management State ---
            const [bankrollStart, setBankrollStart] = useState(() => {
                const saved = localStorage.getItem('bankroll_start');
                return saved ? parseInt(saved) : 3000;
            });
            const [bankrollGoal, setBankrollGoal] = useState(() => {
                const saved = localStorage.getItem('bankroll_goal');
                return saved ? parseInt(saved) : 9000;
            });
            const [bankrollCurrent, setBankrollCurrent] = useState(() => {
                const saved = localStorage.getItem('bankroll_current');
                return saved ? parseInt(saved) : 3000;
            });
            const [bankrollHistory, setBankrollHistory] = useState(() => {
                const saved = localStorage.getItem('bankroll_history');
                return saved ? JSON.parse(saved) : [];
            });

            // Modified RaceMeta to include Strategy and Confidence
            const [raceMeta, setRaceMeta] = useState({
                date: getInitialRaceDate(),
                place: '東京',
                raceNum: 11,
                strategy: 'matchup',
                confidence: 'A', // Default Confidence: ◎
                note: ''
            });

            const [horseCount, setHorseCount] = useState(18); 
            const [betType, setBetType] = useState('tansho');
            const [votingMode, setVotingMode] = useState('box'); 
            
            const [axisHorse, setAxisHorse] = useState(null); 
            const [opponentHorses, setOpponentHorses] = useState([]); 
            const [formation, setFormation] = useState({ first: [], second: [], third: [] });
            const [boxHorses, setBoxHorses] = useState([]);

            const [betList, setBetList] = useState([]);
            const [oddsData, setOddsData] = useState({});
            const [customStakes, setCustomStakes] = useState({});

            const [whatIfRate, setWhatIfRate] = useState(20);
            const [whatIfResult, setWhatIfResult] = useState(null);
            const [showWhatIfResult, setShowWhatIfResult] = useState(false);
            
            const [totalBudget, setTotalBudget] = useState(bankrollCurrent); 
            
            const [allocationMode, setAllocationMode] = useState('profit'); 
            const [budgetInputMode, setBudgetInputMode] = useState('budget'); 
            const [targetProfit, setTargetProfit] = useState(10000);
            const [targetError, setTargetError] = useState(null); 

            const [savedHistory, setSavedHistory] = useState([]);
            
            const [showBankroll, setShowBankroll] = useState(true);
            
            // 確定オッズ入力用ステート
            const [showOddsConfirm, setShowOddsConfirm] = useState(false);
            const [currentWinningBets, setCurrentWinningBets] = useState([]);
            const [finalOddsMap, setFinalOddsMap] = useState({});
            const [tempRaceResultData, setTempRaceResultData] = useState(null); 

            const [toast, setToast] = useState(null);
            const [confirmModal, setConfirmModal] = useState(null);
            
            const [raceResult, setRaceResult] = useState({ first: '', second: '', third: '' });
            const [reflectionNoteInput, setReflectionNoteInput] = useState('');
            const [showResultInput, setShowResultInput] = useState(false);
            const [resultHistory, setResultHistory] = useState([]);
            const [showCourseData, setShowCourseData] = useState(false);
            const [selectedCourse, setSelectedCourse] = useState(raceMeta.place);

            // コースデータをStateで管理
            const [courseData, setCourseData] = useState({});
            const [schedule2026, setSchedule2026] = useState(null);
            const [weekendDates, setWeekendDates] = useState([]);

            // Show toast helper
            const showToast = (message, type = 'success') => {
                setToast({ message, type });
                setTimeout(() => setToast(null), 3000);
            };
            
            // 外部ファイル読み込み
            useEffect(() => {
                fetch('course-data.json')
                    .then(res => {
                        if (!res.ok) throw new Error("File not found");
                        return res.json();
                    })
                    .then(data => setCourseData(data))
                    .catch(err => console.log('JSON読み込み失敗（手動アップロードしてください）', err));
            }, []);

            useEffect(() => {
                async function loadSchedule() {
                    try {
                        const data = await loadSchedule2026();
                        setSchedule2026(data);
                        setWeekendDates(getWeekendDatesForSchedule(data, new Date()));
                    } catch (e) {
                        console.error('Failed to load schedule 2026', e);
                        setSchedule2026({});
                        setWeekendDates([]);
                    }
                }
                loadSchedule();
            }, []);

            const normalizedRaceDate = normalizeDateString(raceMeta.date);
            const allCourses = ALL_COURSES;

            useEffect(() => {
                if (raceMeta.place !== selectedCourse) {
                    setSelectedCourse(raceMeta.place);
                }
            }, [raceMeta.place]);

            useEffect(() => {
                if (!selectedCourse) return;
                if (raceMeta.place !== selectedCourse) {
                    setRaceMeta(prev => ({ ...prev, place: selectedCourse }));
                }
            }, [selectedCourse]);

            const activeCourses = useMemo(() => {
                if (!schedule2026) return allCourses;
                return getActiveCoursesForDate(schedule2026, raceMeta.date, allCourses);
            }, [schedule2026, raceMeta.date, allCourses]);

            const isScheduleMissingForDate = useMemo(() => {
                if (!schedule2026 || !normalizedRaceDate) return false;
                return !schedule2026[normalizedRaceDate];
            }, [schedule2026, normalizedRaceDate]);

            useEffect(() => {
                if (!schedule2026) return;
                const filtered = getActiveCoursesForDate(schedule2026, raceMeta.date, ALL_COURSES);
                if (filtered.length > 0 && !filtered.includes(raceMeta.place)) {
                    setRaceMeta(prev => ({ ...prev, place: filtered[0] }));
                }
            }, [schedule2026, raceMeta.date]);

            // ファイルアップロードハンドラ
            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const json = JSON.parse(e.target.result);
                        setCourseData(json);
                        showToast('コースデータを読み込みました', 'success');
                    } catch (err) {
                        showToast('JSONの形式が正しくありません', 'error');
                    }
                };
                reader.readAsText(file);
            };
            
            // Show confirmation modal
            const showConfirm = (message, onConfirm) => {
                setConfirmModal({ message, onConfirm });
            };
            
            // Handle confirm
            const handleConfirm = () => {
                if (confirmModal?.onConfirm) {
                    confirmModal.onConfirm();
                }
                setConfirmModal(null);
            };
            
            // Load history
            useEffect(() => {
                const saved = localStorage.getItem('jra_odds_history');
                if (saved) {
                    try {
                        setSavedHistory(JSON.parse(saved));
                    } catch (e) {
                        console.error("Failed to load history", e);
                    }
                }
                
                const savedResults = localStorage.getItem('jra_odds_results');
                if (savedResults) {
                    try {
                        setResultHistory(JSON.parse(savedResults));
                    } catch (e) {
                        console.error("Failed to load results", e);
                    }
                }
            }, []);
            
            // Save bankroll data
            useEffect(() => {
                localStorage.setItem('bankroll_start', bankrollStart.toString());
            }, [bankrollStart]);
            
            useEffect(() => {
                localStorage.setItem('bankroll_goal', bankrollGoal.toString());
            }, [bankrollGoal]);
            
            useEffect(() => {
                localStorage.setItem('bankroll_current', bankrollCurrent.toString());
            }, [bankrollCurrent]);
            
            // Meta Change
            const handleMetaChange = (field, value) => {
                if (betList.length > 0) {
                    showConfirm('レース情報を変更すると、現在の買い目リストとオッズはリセットされます。', () => {
                        setRaceMeta(prev => ({ ...prev, [field]: value }));
                        setBetList([]);
                        setOddsData({});
                    });
                } else {
                    setRaceMeta(prev => ({ ...prev, [field]: value }));
                }
            };

            const handleConfidenceClick = (value) => {
                setRaceMeta(prev => ({ ...prev, confidence: value }));
            };

            const handleStrategyClick = (value) => {
                setRaceMeta(prev => ({ ...prev, strategy: value }));
            };

            const renderRaceButton = (num) => {
                const isActive = raceMeta.raceNum === num;

                return (
                    <button
                        key={num}
                        type="button"
                        onClick={() => handleMetaChange('raceNum', num)}
                        className={
                            'race-number-button flex items-center justify-center aspect-square rounded-full text-sm sm:text-base font-semibold ' +
                            'shadow transition mx-auto min-w-[48px] max-w-[64px] border ' +
                            'active:bg-emerald-600 active:text-white ' +
                            (isActive
                                ? 'bg-emerald-600 text-white ring-2 ring-emerald-200 border-emerald-600'
                                : 'bg-white text-emerald-700 border-emerald-200 hover:bg-emerald-50')
                        }
                    >
                        {num}R
                    </button>
                );
            };

            // Nagashi
            const handleNagashiClick = (number) => {
                if (axisHorse === number) {
                    setAxisHorse(null);
                } else if (opponentHorses.includes(number)) {
                    setOpponentHorses(prev => prev.filter(h => h !== number));
                } else {
                    if (axisHorse === null) {
                        setAxisHorse(number);
                    } else {
                        setOpponentHorses(prev => [...prev, number].sort((a, b) => a - b));
                    }
                }
            };

            // Formation
            const toggleFormationHorse = (rowKey, number) => {
                setFormation(prev => {
                    const currentList = prev[rowKey];
                    if (currentList.includes(number)) {
                        return { ...prev, [rowKey]: currentList.filter(n => n !== number) };
                    } else {
                        return { ...prev, [rowKey]: [...currentList, number].sort((a, b) => a - b) };
                    }
                });
            };

            // Box
            const toggleBoxHorse = (number) => {
                setBoxHorses(prev => {
                    if (prev.includes(number)) {
                        return prev.filter(n => n !== number);
                    } else {
                        return [...prev, number].sort((a, b) => a - b);
                    }
                });
            };

            // Clears
            const clearSelection = () => {
                setAxisHorse(null);
                setOpponentHorses([]);
                setFormation({ first: [], second: [], third: [] });
                setBoxHorses([]);
            };

            const clearAll = () => {
                showConfirm('現在の入力内容をすべて消去しますか？', () => {
                    resetInputs();
                    setRaceMeta({
                        date: new Date().toISOString().split('T')[0],
                        place: '東京',
                        raceNum: 11,
                        strategy: 'matchup',
                        confidence: 'A', // Reset confidence
                        note: ''
                    });
                    setBetType('tansho');
                    setVotingMode('box');
                    setTotalBudget(3000);
                    setAllocationMode('profit');
                });
            };

            // Bet Type
            const handleTicketTypeClick = (type) => {
                setBetType(type);
                if (type === 'tansho' || type === 'fukusho') {
                    setVotingMode('box');
                } else {
                    setVotingMode('nagashi');
                }
            };

            // Reset input fields (Reusable function)
            const resetInputs = () => {
                setShowResultInput(false);
                setRaceResult({ first: '', second: '', third: '' });
                setShowOddsConfirm(false);
                
                setBetList([]);
                setOddsData({});
                setCustomStakes({});
                clearSelection();

                // 編集状態を解除（IDリセット）
                setEditingId(null);
                setEditingResultId(null);

                setTotalBudget(bankrollCurrent);
            };

            // History Save/Load/Delete
            const saveToHistory = () => {
                if (betList.length === 0) {
                    showToast('保存する買い目がありません', 'error');
                    return;
                }

                // Use existing ID if editing, otherwise create new ID
                const entryId = editingId || Date.now();

                const newEntry = {
                    id: entryId,
                    meta: { ...raceMeta }, // Includes strategy and confidence
                    data: {
                        betList: [...betList],
                        oddsData: { ...oddsData },
                        totalBudget,
                        allocationMode
                    },
                    savedAt: new Date().toISOString()
                };

                let newHistory;
                
                // Check if updating existing entry
                if (editingId) {
                     newHistory = savedHistory.map(item => 
                        item.id === editingId ? newEntry : item
                    );
                    showToast(`履歴を更新しました`, 'success');
                } else {
                    // Add new entry to top
                    newHistory = [newEntry, ...savedHistory];
                    showToast(`${raceMeta.place} ${raceMeta.raceNum}R を新規保存しました`, 'success');
                }
                
                setSavedHistory(newHistory);
                localStorage.setItem('jra_odds_history', JSON.stringify(newHistory));

                // Reset all inputs and selections after saving
                resetInputs(); 
            };

            const loadFromHistory = (entry) => {
                showConfirm('現在の編集内容を破棄して、保存データを読み込みますか？', () => {
                    clearSelection();
                    setRaceMeta({ ...entry.meta });
                    setBetList([...entry.data.betList]);
                    setOddsData({ ...entry.data.oddsData });
                    setTotalBudget(entry.data.totalBudget || 10000);
                    setAllocationMode(entry.data.allocationMode || 'profit');
                    
                    // Set editing ID to enable overwrite on save
                    setEditingId(entry.id);
                    
                    setCurrentView('calculator');

                    setTimeout(() => {
                        showToast(`${entry.meta.place} ${entry.meta.raceNum}R を読み込みました`, 'success');
                    }, 100);

                    setTimeout(() => {
                        const listSection = document.getElementById('bet-list-section');
                        if (listSection) {
                            listSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    }, 300);
                });
            };

            const loadFromResult = (result) => {
                if (!result.originalData) {
                    showToast('この結果には買い目データが保存されていません', 'error');
                    return;
                }

                // 結果編集専用画面に遷移
                setEditingResultData(result);
                setCurrentView('edit-result');
            };

            const deleteHistoryItem = (id) => {
                showConfirm('この履歴を削除しますか？', () => {
                    const newHistory = savedHistory.filter(item => item.id !== id);
                    setSavedHistory(newHistory);
                    localStorage.setItem('jra_odds_history', JSON.stringify(newHistory));

                    // If deleting currently editing item, reset editing state
                    if (editingId === id) {
                        setEditingId(null);
                    }

                    showToast('履歴を削除しました', 'success');
                });
            };

            const updateResult = (updatedResult) => {
                // 元の結果を取得
                const originalResult = resultHistory.find(item => item.id === updatedResult.id);

                // 当日の日付を取得
                const today = new Date().toISOString().split('T')[0];

                // 当日のレースなら資金を調整
                if (updatedResult.date === today && originalResult) {
                    const profitDiff = updatedResult.profit - originalResult.profit;
                    const current = bankrollCurrent === '' ? 0 : parseInt(bankrollCurrent);
                    const newBankroll = current + profitDiff;
                    setBankrollCurrent(newBankroll);
                    localStorage.setItem('bankroll_current', newBankroll.toString());
                }

                const updatedResults = resultHistory.map(item =>
                    item.id === updatedResult.id ? updatedResult : item
                );
                setResultHistory(updatedResults);
                localStorage.setItem('jra_odds_results', JSON.stringify(updatedResults));

                setEditingResultData(null);
                setCurrentView('results');
                showToast('結果を更新しました', 'success');
            };

            const clearStats = () => {
                showConfirm('全ての統計データ（的中判定の履歴）を削除しますか？\nこの操作は取り消せません。', () => {
                    setResultHistory([]);
                    localStorage.setItem('jra_odds_results', JSON.stringify([]));
                    showToast('統計データを削除しました', 'success');
                });
            };

            // Combination Generator
            const previewCombinations = useMemo(() => {
                let combos = [];
                const sortNums = (arr) => arr.sort((a, b) => a - b);

                if (votingMode === 'box') {
                    if (boxHorses.length === 0) return [];
                    const horses = [...boxHorses];

                    if (betType === 'tansho' || betType === 'fukusho') {
                        horses.forEach(h => {
                            combos.push({ ids: [h], key: `${betType}:${h}`, label: `${h}番`, type: betType });
                        });
                    } else if (betType === 'umaren' || betType === 'wide') {
                        for (let i = 0; i < horses.length; i++) {
                            for (let j = i + 1; j < horses.length; j++) {
                                const sorted = sortNums([horses[i], horses[j]]);
                                combos.push({ ids: sorted, key: `${betType}:${sorted.join('-')}`, label: sorted.join('-'), type: betType });
                            }
                        }
                    } else if (betType === 'umatan') {
                        for (let i = 0; i < horses.length; i++) {
                            for (let j = 0; j < horses.length; j++) {
                                if (i === j) continue;
                                const combo = [horses[i], horses[j]];
                                combos.push({ ids: combo, key: `${betType}:${combo.join('>')}`, label: combo.join('>'), type: betType });
                            }
                        }
                    } else if (betType === 'sanrenpuku') {
                        for (let i = 0; i < horses.length; i++) {
                            for (let j = i + 1; j < horses.length; j++) {
                                for (let k = j + 1; k < horses.length; k++) {
                                    const sorted = sortNums([horses[i], horses[j], horses[k]]);
                                    combos.push({ ids: sorted, key: `${betType}:${sorted.join('-')}`, label: sorted.join('-'), type: betType });
                                }
                            }
                        }
                    } else if (betType === 'sanrentan') {
                        for (let i = 0; i < horses.length; i++) {
                            for (let j = 0; j < horses.length; j++) {
                                for (let k = 0; k < horses.length; k++) {
                                    if (i === j || j === k || i === k) continue;
                                    const combo = [horses[i], horses[j], horses[k]];
                                    combos.push({ ids: combo, key: `${betType}:${combo.join('>')}`, label: combo.join('>'), type: betType });
                                }
                            }
                        }
                    }
                } else if (votingMode === 'nagashi') {
                    if (!axisHorse || opponentHorses.length === 0) return [];
                    const opps = [...opponentHorses];

                    if (betType === 'umaren' || betType === 'wide') {
                        opps.forEach(opp => {
                            const combo = sortNums([axisHorse, opp]);
                            combos.push({ ids: combo, key: `${betType}:${combo.join('-')}`, label: combo.join('-'), type: betType });
                        });
                    } else if (betType === 'umatan') {
                        opps.forEach(opp => {
                            const combo = [axisHorse, opp];
                            combos.push({ ids: combo, key: `${betType}:${combo.join('>')}`, label: combo.join('>'), type: betType });
                        });
                    } else if (betType === 'sanrenpuku') {
                        if (opps.length < 2) return [];
                        for (let i = 0; i < opps.length; i++) {
                            for (let j = i + 1; j < opps.length; j++) {
                                const raw = [axisHorse, opps[i], opps[j]];
                                const sorted = sortNums(raw);
                                combos.push({ ids: sorted, key: `${betType}:${sorted.join('-')}`, label: sorted.join('-'), type: betType });
                            }
                        }
                    } else if (betType === 'sanrentan') {
                        if (opps.length < 2) return [];
                        for (let i = 0; i < opps.length; i++) {
                            for (let j = 0; j < opps.length; j++) {
                                if (i === j) continue;
                                const combo = [axisHorse, opps[i], opps[j]];
                                combos.push({ ids: combo, key: `${betType}:${combo.join('>')}`, label: combo.join('>'), type: betType });
                            }
                        }
                    }
                } else if (votingMode === 'formation') {
                    const { first, second, third } = formation;
                    const isUnique = (arr) => new Set(arr).size === arr.length;

                    if (betType === 'umaren' || betType === 'wide') {
                        if (first.length === 0 || second.length === 0) return [];
                        const seen = new Set();
                        first.forEach(f => {
                            second.forEach(s => {
                                if (f === s) return;
                                const sorted = sortNums([f, s]);
                                const uniqueKey = sorted.join('-');
                                if (!seen.has(uniqueKey)) {
                                    seen.add(uniqueKey);
                                    combos.push({ ids: sorted, key: `${betType}:${uniqueKey}`, label: uniqueKey, type: betType });
                                }
                            });
                        });
                    } else if (betType === 'umatan') {
                        if (first.length === 0 || second.length === 0) return [];
                        first.forEach(f => {
                            second.forEach(s => {
                                if (f === s) return;
                                const label = `${f}>${s}`;
                                combos.push({ ids: [f, s], key: `${betType}:${label}`, label, type: betType });
                            });
                        });
                    } else if (betType === 'sanrenpuku') {
                        if (first.length === 0 || second.length === 0 || third.length === 0) return [];
                        const seen = new Set();
                        first.forEach(f => {
                            second.forEach(s => {
                                third.forEach(t => {
                                    if (!isUnique([f, s, t])) return;
                                    const sorted = sortNums([f, s, t]);
                                    const uniqueKey = sorted.join('-');
                                    if (!seen.has(uniqueKey)) {
                                        seen.add(uniqueKey);
                                        combos.push({ ids: sorted, key: `${betType}:${uniqueKey}`, label: uniqueKey, type: betType });
                                    }
                                });
                            });
                        });
                    } else if (betType === 'sanrentan') {
                        if (first.length === 0 || second.length === 0 || third.length === 0) return [];
                        first.forEach(f => {
                            second.forEach(s => {
                                third.forEach(t => {
                                    if (!isUnique([f, s, t])) return;
                                    const label = `${f}>${s}>${t}`;
                                    combos.push({ ids: [f, s, t], key: `${betType}:${label}`, label, type: betType });
                                });
                            });
                        });
                    }
                }

                return combos;
            }, [axisHorse, opponentHorses, formation, boxHorses, betType, votingMode]);

            const addBetsToList = () => {
                if (previewCombinations.length === 0) return;
                setBetList(prev => {
                    const existingKeys = new Set(prev.map(b => b.key));
                    const newBets = previewCombinations.filter(b => !existingKeys.has(b.key));
                    return [...prev, ...newBets];
                });
            };

            const removeBet = (key) => {
                setBetList(prev => prev.filter(b => b.key !== key));
            };

            const handleOddsChange = (key, value) => {
                setOddsData(prev => ({ ...prev, [key]: parseFloat(value) }));
            };

            const handleStakeChange = (key, value) => {
                const val = value === '' ? '' : parseInt(value);
                setCustomStakes(prev => ({ ...prev, [key]: val }));
            };

            const calculateBudgetFromTarget = () => {
                setTargetError(null);
                
                if (betList.length === 0) {
                    setTargetError('買い目を追加してください');
                    return;
                }
                
                let inverseSum = 0;
                let hasValidOdds = false;
                
                for (const bet of betList) {
                    const odds = oddsData[bet.key];
                    if (odds > 0) {
                        inverseSum += 1 / odds;
                        hasValidOdds = true;
                    }
                }
                
                if (!hasValidOdds) {
                    setTargetError('オッズを入力してください');
                    return;
                }
                
                if (inverseSum >= 1.0) {
                    setTargetError('⚠️ オッズが低すぎます。目標達成は不可能です。');
                    return;
                }
                
                const target = targetProfit === '' ? 0 : targetProfit;
                const totalPayout = target / (1 - inverseSum);
                const requiredBudget = Math.ceil((totalPayout - target) / 100) * 100; 
                
                setTotalBudget(requiredBudget);
                setAllocationMode('profit'); 
                setCustomStakes({}); 
            };

            // バンクロール履歴操作関数
            const saveBankrollSession = () => {
                const start = bankrollStart === '' ? 0 : parseInt(bankrollStart);
                const current = bankrollCurrent === '' ? 0 : parseInt(bankrollCurrent);
                const goal = bankrollGoal === '' ? 0 : parseInt(bankrollGoal);

                const profit = current - start;
                const profitPercentage = start > 0 ? ((profit / start) * 100).toFixed(1) : 0;

                // 日付をYYYY-MM-DD形式で保存（結果画面の日付と一致させる）
                const today = new Date();
                const dateString = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

                const newRecord = {
                    id: Date.now(),
                    date: dateString,
                    start: start,
                    end: current,
                    goal: goal,
                    profit: profit,
                    percent: profitPercentage,
                    isGoal: current >= (start + goal)
                };

                const newHistory = [newRecord, ...bankrollHistory];
                setBankrollHistory(newHistory);
                localStorage.setItem('bankroll_history', JSON.stringify(newHistory));

                showToast('本日の収支を記録しました', 'success');
            };

            const deleteBankrollRecord = (id) => {
                showConfirm('この記録を削除しますか？', () => {
                    const newHistory = bankrollHistory.filter(item => item.id !== id);
                    setBankrollHistory(newHistory);
                    localStorage.setItem('bankroll_history', JSON.stringify(newHistory));
                    showToast('記録を削除しました', 'success');
                });
            };

            // Check which bets won based on race result
            const checkResults = () => {
                const { first, second, third } = raceResult;

                if (!first || !second || !third) {
                    showToast('着順を全て入力してください', 'error');
                    return;
                }

                const r1 = parseInt(first);
                const r2 = parseInt(second);
                const r3 = parseInt(third);
                
                const results = betList.map(bet => {
                    let isWin = false;
                    const ids = bet.ids.map(id => parseInt(id));

                    switch (bet.type) {
                        case 'tansho': 
                            isWin = ids[0] === r1; 
                            break;
                        case 'fukusho': 
                            isWin = ids[0] === r1 || ids[0] === r2 || ids[0] === r3; 
                            break;
                        case 'wide': 
                            const winners = [r1, r2, r3];
                            isWin = winners.includes(ids[0]) && winners.includes(ids[1]);
                            break;
                        case 'umaren': 
                            const umarenWinners = [r1, r2]; 
                            isWin = umarenWinners.includes(ids[0]) && umarenWinners.includes(ids[1]);
                            break;
                        case 'umatan': 
                            isWin = (ids[0] === r1 && ids[1] === r2); 
                            break;
                        case 'sanrenpuku': 
                            const sanrenWinners = [r1, r2, r3];
                            isWin = sanrenWinners.includes(ids[0]) && sanrenWinners.includes(ids[1]) && sanrenWinners.includes(ids[2]);
                            break;
                        case 'sanrentan': 
                            isWin = (ids[0] === r1 && ids[1] === r2 && ids[2] === r3); 
                            break;
                    }
                    return { ...bet, isWin };
                });
                
                const totalInvested = calculatedData.reduce((sum, bet) => sum + (bet.stake || 0), 0);

                const winning = results.filter(r => r.isWin);
                
                if (winning.length > 0) {
                    const initialFinalOdds = {};
                    winning.forEach(bet => {
                        let defaultOdds = oddsData[bet.key] || '';
                        initialFinalOdds[bet.key] = defaultOdds;
                    });
                    
                    setFinalOddsMap(initialFinalOdds);
                    setCurrentWinningBets(winning);
                    setTempRaceResultData({ results, totalInvested });
                    setShowOddsConfirm(true);
                    return;
                }
                
                const profit = -totalInvested; 
                const current = bankrollCurrent === '' ? 0 : parseInt(bankrollCurrent);
                const newBankroll = current + profit;
                
                const resultMessage = `残念...的中はありませんでした。
投資額: ${totalInvested.toLocaleString()}円
回収: 0円
収支: ${profit.toLocaleString()}円

💰 資金更新: ${current.toLocaleString()}円 → ${newBankroll.toLocaleString()}円`;

                showConfirm(
                    resultMessage,
                    () => {
                        finalizeBatch(results, totalInvested, {});
                    }
                );
            };

            const finalizeBatch = (results, totalInvested, finalOdds) => {
                const winCount = results.filter(r => r.isWin).length;

                const totalReturn = results.reduce((sum, bet) => {
                    if (!bet.isWin) return sum;
                    const betData = calculatedData.find(row => row.key === bet.key);
                    if (!betData) return sum;
                    
                    const actualOdds = parseFloat(finalOdds[bet.key]) || 0;
                    return sum + Math.floor(betData.stake * actualOdds);
                }, 0);
                
                const profit = totalReturn - totalInvested;

                const current = bankrollCurrent === '' ? 0 : parseInt(bankrollCurrent);
                const newBankroll = current + profit;
                setBankrollCurrent(newBankroll);

                const effectiveOddsInfo = calculateEffectiveOdds(effectiveOddsBets);

                const resultRecord = {
                    id: Date.now(),
                    date: raceMeta.date,
                    place: raceMeta.place,
                    raceNum: raceMeta.raceNum,
                    note: raceMeta.note,
                    strategy: raceMeta.strategy || 'data', // Save Strategy
                    confidence: raceMeta.confidence || 'A', // Save Confidence
                    result: { first: parseInt(raceResult.first), second: parseInt(raceResult.second), third: parseInt(raceResult.third) },
                    totalBets: betList.length,
                    winCount: winCount,
                    totalInvested: totalInvested,
                    totalReturn: totalReturn,
                    profit: profit,
                    effectiveOdds: effectiveOddsInfo.effectiveOdds,
                    reflectionNote: reflectionNoteInput, // 的中判定時に入力された反省ノート
                    bets: betList.map(bet => {
                        const betData = calculatedData.find(row => row.key === bet.key);
                        const isWin = results.find(r => r.key === bet.key)?.isWin || false;
                        const purchaseOdds = betData?.odds || 0;
                        const finalOddValue = isWin ? (parseFloat(finalOdds[bet.key]) || purchaseOdds) : purchaseOdds;

                        return {
                            type: bet.type,
                            combination: bet.label,
                            odds: purchaseOdds,
                            resultOdds: finalOddValue,
                            stake: betData?.stake || 0,
                            isWin: isWin
                        };
                    }),
                    // 編集可能にするため、元の買い目データも保存
                    originalData: {
                        betList: [...betList],
                        oddsData: { ...oddsData },
                        totalBudget,
                        allocationMode
                    }
                };

                // 新しい結果を追加
                const updatedResults = [...resultHistory, resultRecord];
                setResultHistory(updatedResults);
                localStorage.setItem('jra_odds_results', JSON.stringify(updatedResults));
                
                // 共通のリセット処理
                const resetGameState = () => {
                    setShowResultInput(false);
                    setRaceResult({ first: '', second: '', third: '' });
                    setReflectionNoteInput('');
                    setShowOddsConfirm(false);

                    // 買い目・オッズ・選択状態をすべてリセット
                    setBetList([]);
                    setOddsData({});
                    setCustomStakes({});
                    clearSelection();

                    // 予算を現在資金に合わせて更新（オプション）
                    setTotalBudget(newBankroll);

                    // 編集IDもクリア
                    setEditingId(null);
                    setEditingResultId(null);
                };

                if (winCount > 0) {
                    const resultMessage = `的中: ${winCount}点 / ${betList.length}点
投資額: ${totalInvested.toLocaleString()}円
払戻: ${totalReturn.toLocaleString()}円
収支: ${profit >= 0 ? '+' : ''}${profit.toLocaleString()}円

💰 資金更新: ${current.toLocaleString()}円 → ${newBankroll.toLocaleString()}円`;
                    
                    showConfirm(
                        resultMessage,
                        () => {
                            resetGameState();
                        }
                    );
                } else {
                    // 的中なしの場合（メッセージはcheckResultsで表示済みなのでリセットのみ）
                    resetGameState();
                }
            };

            const handleFinalOddsSubmit = () => {
                if (!tempRaceResultData) return;
                finalizeBatch(tempRaceResultData.results, tempRaceResultData.totalInvested, finalOddsMap);
            };

            const calculatedData = useMemo(() => {
                if (betList.length === 0) return [];
                
                const budget = totalBudget === '' ? 0 : parseInt(totalBudget);
                
                const results = betList.map(c => ({ ...c, odds: oddsData[c.key] || 0 }));
                const validBets = results.filter(r => r.odds > 0);
                
                if (validBets.length === 0) {
                    return results.map(r => ({ ...r, stake: 0, return: 0, profit: -budget }));
                }

                if (allocationMode === 'flat') {
                    const stakePerBet = Math.floor((budget / results.length) / 100) * 100;
                    const betsWithStakes = results.map(r => {
                        const customStake = customStakes[r.key];
                        const actualStake = (customStake !== undefined && customStake !== '') ? customStake : stakePerBet;
                        return { ...r, stake: actualStake };
                    });
                    
                    const actualTotal = betsWithStakes.reduce((sum, item) => sum + item.stake, 0);
                    return betsWithStakes.map(r => ({
                        ...r,
                        return: Math.floor(r.stake * r.odds),
                        profit: Math.floor(r.stake * r.odds) - actualTotal
                    }));
                } else {
                    const sumInverseOdds = validBets.reduce((acc, curr) => {
                        return acc + (1 / curr.odds);
                    }, 0);
                    
                    const calculatedBets = results.map(r => {
                        if (r.odds <= 0) return { ...r, stake: 0, return: 0, profit: 0 };
                        let rawStake = (budget / sumInverseOdds) / r.odds;
                        let stake = Math.round(rawStake / 100) * 100;
                        if (stake < 100) stake = 100;
                        return { ...r, stake };
                    });

                    let currentTotal = calculatedBets.reduce((sum, item) => sum + item.stake, 0);
                    const finalBets = calculatedBets.map(r => {
                        const customStake = customStakes[r.key];
                        const actualStake = (customStake !== undefined && customStake !== '') ? customStake : r.stake;
                        return { ...r, stake: actualStake };
                    });
                    const actualTotal = finalBets.reduce((sum, item) => sum + item.stake, 0);
                    return finalBets.map(r => ({
                        ...r,
                        return: Math.floor(r.stake * r.odds),
                        profit: Math.floor(r.stake * r.odds) - actualTotal
                    }));
                }
            }, [betList, oddsData, totalBudget, allocationMode, customStakes]);

            const stats = useMemo(() => {
                const totalStake = calculatedData.reduce((acc, curr) => acc + curr.stake, 0);

                return { totalStake, count: betList.length };
            }, [calculatedData, betList]);

            const effectiveOddsBets = useMemo(() => {
                return calculatedData.map(bet => ({
                    amount: Number(bet.stake) || 0,
                    odds: Number(bet.odds) || 0
                }));
            }, [calculatedData]);

            const runWhatIfSimulation = () => {
                if (calculatedData.length === 0) {
                    setWhatIfResult(null);
                    setShowWhatIfResult(false);
                    return;
                }

                const rate = whatIfRate / 100;
                const totalStake = calculatedData.reduce((sum, b) => sum + (Number(b.stake) || 0), 0);

                const buildBetLabel = (bet, index) => {
                    const baseLabel = bet.label || `#${index + 1}`;
                    const typeName = getTypeName ? getTypeName(bet.type) : '';
                    if (!typeName) return baseLabel;
                    if (bet.type === 'tansho' || bet.type === 'fukusho') return `${typeName} ${baseLabel}番`;
                    return `${typeName} ${baseLabel}`;
                };

                let minProfit = Infinity;
                let maxProfit = -Infinity;
                let losersCount = 0;
                let winnersCount = 0;
                let breakevenCount = 0;

                const details = calculatedData.map((bet, index) => {
                    const amount = Number(bet.stake) || 0;
                    const originalOdds = Number(bet.odds) || 0;
                    const simulatedOdds = Math.max(1.0, originalOdds * (1 - rate));
                    const payout = simulatedOdds * amount;
                    const rawProfit = payout - totalStake;
                    const profit = Math.abs(rawProfit) <= 1 ? 0 : Math.round(rawProfit);

                    if (rawProfit < minProfit) minProfit = rawProfit;
                    if (rawProfit > maxProfit) maxProfit = rawProfit;

                    if (profit < 0) losersCount += 1;
                    else if (profit > 0) winnersCount += 1;
                    else breakevenCount += 1;

                    return {
                        id: bet.key || bet.id || `bet-${index}`,
                        label: buildBetLabel(bet, index),
                        originalOdds,
                        simulatedOdds,
                        amount,
                        payout,
                        profit,
                    };
                });

                if (!Number.isFinite(minProfit) || !Number.isFinite(maxProfit)) {
                    setWhatIfResult(null);
                    setShowWhatIfResult(false);
                    return;
                }

                setWhatIfResult({
                    rate: whatIfRate,
                    totalStake,
                    minProfit,
                    maxProfit,
                    details,
                    losersCount,
                    winnersCount,
                    breakevenCount,
                });

                setShowWhatIfResult(true);
            };

            useEffect(() => {
                if (betList.length === 0) {
                    setWhatIfResult(null);
                    setShowWhatIfResult(false);
                }
            }, [betList]);

            const handleWhatIfToggle = () => {
                if (showWhatIfResult) {
                    setShowWhatIfResult(false);
                } else {
                    runWhatIfSimulation();
                }
            };

            const bankrollStatus = useMemo(() => {
                const start = bankrollStart === '' ? 0 : parseInt(bankrollStart);
                const goal = bankrollGoal === '' ? 0 : parseInt(bankrollGoal);
                const current = bankrollCurrent === '' ? 0 : parseInt(bankrollCurrent);

                const targetAmount = start + goal;
                const profit = current - start;
                const profitPercentage = start > 0 ? ((profit / start) * 100).toFixed(1) : 0;
                const progressPercentage = goal > 0 ? Math.min(100, Math.max(0, (profit / goal) * 100)) : 0;
                
                let status = { type: 'normal', color: 'emerald', bgColor: 'bg-emerald-500', borderColor: 'border-emerald-400', textColor: 'text-emerald-800', emoji: '🟢', message: '' };
                
                if (current >= targetAmount) {
                    status = { type: 'goal', color: 'yellow', bgColor: 'bg-gradient-to-r from-yellow-400 to-yellow-500', borderColor: 'border-yellow-400', textColor: 'text-yellow-900', emoji: '🎉', message: '目標達成！ 素晴らしい成果です。今日はここで『勝ち逃げ』しませんか？' };
                } else if (current <= start * 0.5) {
                    status = { type: 'danger', color: 'red', bgColor: 'bg-red-500', borderColor: 'border-red-400', textColor: 'text-red-900', emoji: '⚠️', message: '警告：資金の50%を失いました。一度休憩して冷静になりましょう。' };
                } else {
                    status.message = `現在収支: ${profit >= 0 ? '+' : ''}${profit.toLocaleString()}円。冷静に目標を目指しましょう。`;
                }
                
                return { targetAmount, profit, profitPercentage, progressPercentage, status };
            }, [bankrollStart, bankrollGoal, bankrollCurrent]);

            const renderHorseButton = (num, isSelected, colorClass, onClick) => (
                <button key={num} onClick={onClick} className={`h-12 sm:h-9 w-full rounded border text-lg sm:text-sm font-bold transition-all active:scale-95 ${isSelected ? `${colorClass} text-white shadow-md ring-1 ring-opacity-50` : "bg-white border-gray-300 text-gray-600 hover:bg-gray-50"}`}>{num}</button>
            );

            const getRowLabel = (index, type) => {
                if (type === 'sanrenpuku' || type === 'umaren' || type === 'wide') return `${index}頭目`;
                return `${index}着`;
            };

            const getTicketTypeLabel = (value) => TICKET_TYPES.find(t => t.value === value)?.label || '';

            const getTypeName = (type) => getTicketTypeLabel(type) || type;

            const isSingleHorseBet = betType === 'tansho' || betType === 'fukusho';

            const orderedTicketTypes = useMemo(
                () =>
                    TICKET_ORDER
                        .map((value) => TICKET_TYPES.find((t) => t.value === value))
                        .filter(Boolean),
                []
            );

            const renderTicketButton = (type) => {
                const isActive = betType === type.value;

                return (
                    <button
                        key={type.value}
                        type="button"
                        onClick={() => handleTicketTypeClick(type.value)}
                        className={
                            'pill-button text-sm font-semibold w-full min-w-[90px] ' +
                            (isActive
                                ? 'pill-active bg-indigo-600 text-white border-indigo-600'
                                : 'bg-white text-indigo-700 border-indigo-300 hover:bg-indigo-50')
                        }
                    >
                        {type.label}
                    </button>
                );
            };

            const formatDateDisplay = (dateStr) => {
                const d = new Date(dateStr);
                return `${d.getMonth() + 1}/${d.getDate()}`;
            };

            // MAIN RENDER
            return (
                <div className="w-full min-h-screen bg-slate-50 text-slate-900 pb-24">
                    {/* (Omitted: Modals and Header remain same) */}
                    {showOddsConfirm && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4">
                            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 transform transition-all animate-slide-in">
                                <div className="flex items-center gap-3 mb-4">
                                    <div className="w-12 h-12 bg-emerald-100 rounded-full flex items-center justify-center"><Icons.DollarSign size={24} className="text-emerald-600" /></div>
                                    <h3 className="text-lg font-bold text-gray-800">的中！確定オッズ入力</h3>
                                </div>
                                <p className="text-sm text-gray-600 mb-4">的中した買い目の<strong>確定オッズ</strong>を入力してください。<br/>（初期値は予想時のオッズです）</p>
                                
                                <div className="max-h-60 overflow-y-auto mb-4 space-y-3 pr-1">
                                    {currentWinningBets.map(bet => (
                                        <div key={bet.key} className="flex items-center justify-between bg-gray-50 p-2 rounded border">
                                            <div className="flex flex-col">
                                                <span className="text-xs text-gray-500 font-bold">{getTypeName(bet.type)}</span>
                                                <span className="font-mono font-bold text-lg text-gray-700">{bet.label}</span>
                                            </div>
                                            <div className="flex items-center gap-2">
                                                <span className="text-xs text-gray-500">倍率:</span>
                                                <input 
                                                    type="number" 
                                                    step="0.1" 
                                                    value={finalOddsMap[bet.key] || ''}
                                                    onChange={(e) => setFinalOddsMap(prev => ({ ...prev, [bet.key]: e.target.value }))}
                                                    className="w-20 border border-emerald-300 rounded px-2 py-1 text-right font-bold text-lg focus:ring-2 focus:ring-emerald-500 outline-none"
                                                />
                                            </div>
                                        </div>
                                    ))}
                                </div>

                                <div className="flex gap-3">
                                    <button onClick={() => setShowOddsConfirm(false)} className="flex-1 px-4 py-3 bg-gray-200 text-gray-700 rounded-lg font-bold hover:bg-gray-300 transition-colors">キャンセル</button>
                                    <button onClick={handleFinalOddsSubmit} className="flex-1 px-4 py-3 bg-emerald-600 text-white rounded-lg font-bold hover:bg-emerald-700 transition-colors">結果を確定</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {confirmModal && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4">
                            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 transform transition-all animate-slide-in">
                                <div className="flex items-center gap-3 mb-4">
                                    <div className="w-12 h-12 bg-yellow-100 rounded-full flex items-center justify-center"><Icons.Info size={24} className="text-yellow-600" /></div>
                                    <h3 className="text-lg font-bold text-gray-800">確認</h3>
                                </div>
                                <p className="text-gray-600 mb-6 leading-relaxed whitespace-pre-line">{confirmModal.message}</p>
                                <div className="flex gap-3">
                                    <button onClick={() => setConfirmModal(null)} className="flex-1 px-4 py-3 bg-gray-200 text-gray-700 rounded-lg font-bold hover:bg-gray-300 transition-colors">キャンセル</button>
                                    <button onClick={handleConfirm} className="flex-1 px-4 py-3 bg-emerald-600 text-white rounded-lg font-bold hover:bg-emerald-700 transition-colors">OK</button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {toast && (
                        <div className={`fixed top-20 right-4 z-50 px-6 py-4 rounded-lg shadow-2xl transform transition-all duration-300 ${toast.type === 'success' ? 'bg-emerald-600' : 'bg-red-500'} text-white font-bold flex items-center gap-3 animate-slide-in`}>
                            {toast.type === 'success' ? <Icons.CheckSquare size={24} /> : <Icons.X size={24} />}
                            <span>{toast.message}</span>
                        </div>
                    )}

                    {showHelp && (
                        <HelpOverlay onClose={() => setShowHelp(false)} />
                    )}

                    <header className="w-full bg-emerald-700 sticky top-0 z-30">
                        <div className="flex justify-between items-center relative px-3 py-3 sm:px-4">
                            <h1 className="text-xl font-bold flex items-center gap-2 text-white"><Icons.Calculator size={20} /> ODDS MASTER</h1>
                            <div className="flex items-center">
                                <button
                                    type="button"
                                    onClick={() => setMenuOpen((prev) => !prev)}
                                    className={`ml-2 px-3 py-2 rounded border flex items-center gap-1 transition-colors ${menuOpen ? 'bg-white/20 border-white text-white' : 'border-white/70 text-white hover:bg-white/10'}`}
                                >
                                    <Icons.Menu size={18} />
                                </button>
                                {menuOpen && (
                                    <div className="absolute right-0 top-12 bg-white text-sm rounded shadow-lg border z-50 min-w-[160px]">
                                        <button
                                            className="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2 text-gray-800 font-semibold border-b border-gray-100"
                                            onClick={() => { setShowHelp(true); setMenuOpen(false); }}
                                        >
                                            <Icons.Info size={14} /> ODDS MASTERの内容について
                                        </button>
                                        <button
                                            className="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2 text-gray-800"
                                            onClick={() => { setCurrentView('courseData'); setMenuOpen(false); }}
                                        >
                                            <Icons.BookOpen size={14} /> コース
                                        </button>
                                        <button
                                            className="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2 text-gray-800"
                                            onClick={() => { setCurrentView('results'); setMenuOpen(false); }}
                                        >
                                            <Icons.Award size={14} /> 結果
                                        </button>
                                        <button
                                            className="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2 text-gray-800"
                                            onClick={() => { setCurrentView('history'); setMenuOpen(false); }}
                                        >
                                            <Icons.History size={14} /> 買い目
                                        </button>
                                    </div>
                                )}
                            </div>
                        </div>
                    </header>

                    {currentView === 'calculator' && (
                        <main className="w-full px-3 sm:px-4 pt-4 pb-10 app-main">
                            <section className="w-full -mx-3 sm:-mx-4 bg-slate-50">
                                <div className="w-full bg-emerald-700 text-white flex items-center justify-between px-4 py-3">
                                    <div className="flex items-center gap-2">
                                        <Icons.TrendingUp size={20} />
                                        <span className="font-bold text-lg">Today's Bankroll</span>
                                        <span className="text-xs bg-white/20 px-2 py-0.5 rounded">{bankrollStatus.profit >= 0 ? '+' : ''}{bankrollStatus.profit.toLocaleString()}円</span>
                                    </div>
                                    <button onClick={() => setShowBankroll(!showBankroll)} className="text-white">
                                        {showBankroll ? <Icons.ChevronUp size={20} /> : <Icons.ChevronDown size={20} />}
                                    </button>
                                </div>

                                {showBankroll && (
                                    <div className="w-full px-4 sm:px-6 py-4 space-y-4">
                                        <div className="grid grid-cols-3 gap-3">
                                            <div>
                                                <label className="text-xs font-bold text-gray-500 block mb-1">開始資金</label>
                                                <div className="relative">
                                                    <input 
                                                        type="number" 
                                                        step="1000" 
                                                        value={bankrollStart === 0 ? '' : bankrollStart} 
                                                        onChange={(e) => setBankrollStart(e.target.value === '' ? '' : parseInt(e.target.value))} 
                                                        className="w-full border border-gray-300 rounded px-2 py-1.5 pr-8 text-sm text-right font-mono focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500" 
                                                        placeholder="0" 
                                                    />
                                                    <span className="absolute right-2 top-1/2 transform -translate-y-1/2 text-xs text-gray-400 pointer-events-none">円</span>
                                                </div>
                                            </div>
                                            <div>
                                                <label className="text-xs font-bold text-gray-500 block mb-1">目標利益</label>
                                                <div className="relative">
                                                    <input 
                                                        type="number" 
                                                        step="1000" 
                                                        value={bankrollGoal === 0 ? '' : bankrollGoal} 
                                                        onChange={(e) => setBankrollGoal(e.target.value === '' ? '' : parseInt(e.target.value))} 
                                                        className="w-full border border-gray-300 rounded px-2 py-1.5 pr-8 text-sm text-right font-mono focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500" 
                                                        placeholder="0" 
                                                    />
                                                    <span className="absolute right-2 top-1/2 transform -translate-y-1/2 text-xs text-gray-400 pointer-events-none">円</span>
                                                </div>
                                            </div>
                                            <div>
                                                <label className="text-xs font-bold text-gray-500 block mb-1">現在資金</label>
                                                <div className="relative">
                                                    <input 
                                                        type="number" 
                                                        step="100" 
                                                        value={bankrollCurrent === 0 ? '' : bankrollCurrent} 
                                                        onChange={(e) => setBankrollCurrent(e.target.value === '' ? '' : parseInt(e.target.value))} 
                                                        className="w-full border border-gray-300 rounded px-2 py-1.5 pr-8 text-sm text-right font-mono focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500" 
                                                        placeholder="0" 
                                                    />
                                                    <span className="absolute right-2 top-1/2 transform -translate-y-1/2 text-xs text-gray-400 pointer-events-none">円</span>
                                                </div>
                                            </div>
                                        </div>

                                        <div className="space-y-2">
                                            <div className="flex justify-between text-xs text-gray-600">
                                                <span>開始: {(bankrollStart === '' ? 0 : bankrollStart).toLocaleString()}円</span>
                                                <span className="font-bold text-emerald-700">目標金額: {bankrollStatus.targetAmount.toLocaleString()}円</span>
                                            </div>
                                            <div className="relative w-full h-8 bg-gray-200 rounded-full overflow-hidden shadow-inner">
                                                <div
                                                    className={`h-full transition-all duration-500 ${bankrollStatus.status.bgColor} flex items-center justify-end px-3`}
                                                    style={{ width: `${bankrollStatus.progressPercentage}%` }}
                                                >
                                                    {bankrollStatus.progressPercentage > 20 && (
                                                        <span className="text-xs font-bold text-white drop-shadow">
                                                            {bankrollStatus.progressPercentage.toFixed(0)}%
                                                        </span>
                                                    )}
                                                </div>
                                                {bankrollStatus.progressPercentage <= 20 && bankrollStatus.progressPercentage > 0 && (
                                                    <span className="absolute left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2 text-xs font-bold text-gray-600">
                                                        {bankrollStatus.progressPercentage.toFixed(0)}%
                                                    </span>
                                                )}
                                            </div>
                                            <div className="flex justify-between text-xs">
                                                <span className={`font-bold ${bankrollStatus.profit >= 0 ? 'text-emerald-600' : 'text-red-600'}`}>
                                                    現在: {(bankrollCurrent === '' ? 0 : bankrollCurrent).toLocaleString()}円 ({bankrollStatus.profit >= 0 ? '+' : ''}{bankrollStatus.profitPercentage}%)
                                                </span>
                                            </div>
                                        </div>

                                        <div className={`w-full p-3 rounded-lg border-l-4 ${bankrollStatus.status.type === 'goal' ? 'bg-yellow-50 border-yellow-400' : bankrollStatus.status.type === 'danger' ? 'bg-red-50 border-red-400' : 'bg-emerald-50 border-emerald-400'}`}>
                                            <div className="flex items-start gap-2">
                                                <span className="text-xl">{bankrollStatus.status.emoji}</span>
                                                <p className={`text-sm font-bold ${bankrollStatus.status.textColor}`}>
                                                    {bankrollStatus.status.message}
                                                </p>
                                            </div>
                                        </div>

                                        <div className="pt-2 border-t border-gray-100">
                                            <button
                                                onClick={saveBankrollSession}
                                                className="w-full bg-blue-600 text-white py-3 px-3 rounded-lg font-bold text-sm hover:bg-blue-700 flex items-center justify-center gap-2"
                                            >
                                                <Icons.Save size={16} />
                                                今日の記録を保存
                                            </button>
                                            <div className="text-[10px] text-gray-400 px-1 mt-2 text-center">
                                                ※現在の資金を維持したまま、今日の収支を記録します
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </section>

                            <section className="w-full bg-white border-b border-slate-200 px-3 py-5 sm:px-4">
                                <div className="grid grid-cols-2 sm:grid-cols-12 gap-3">
                                    <div className="col-span-2 sm:col-span-3">
                                        <label className="flex items-center gap-1 text-xs text-gray-500 font-bold mb-1"><Icons.Calendar size={12} /> 日付</label>
                                        <div className="flex flex-col gap-3">
                                            <div>
                                                <div className="text-xs font-semibold text-gray-600 mb-2">
                                                    今週の開催日
                                                </div>
                                                <div className="flex flex-wrap gap-2 pill-group">
                                                    {weekendDates.length === 0 && (
                                                        <span className="text-xs text-gray-400">
                                                            スケジュール情報が取得できなかったため、開催日ボタンを表示できませんでした。
                                                        </span>
                                                    )}
                                                    {weekendDates.map((wd) => {
                                                        const isActive = raceMeta.date === wd.key;
                                                        const label = `${wd.key.slice(5)}（${wd.label}）`;

                                                        return (
                                                            <button
                                                                key={wd.key}
                                                                type="button"
                                                                onClick={() => {
                                                                    setRaceMeta(prev => ({ ...prev, date: wd.key }));
                                                                }}
                                                                className={
                                                                    'pill-button text-sm font-semibold min-w-[120px] sm:min-w-[136px] h-[48px] whitespace-nowrap flex items-center justify-center px-4 ' +
                                                                    (isActive
                                                                        ? 'pill-active bg-emerald-600 text-white border-emerald-600'
                                                                        : 'bg-white text-emerald-700 border-emerald-300 hover:bg-emerald-50')
                                                                }
                                                            >
                                                                {label}
                                                            </button>
                                                        );
                                                    })}
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div className="col-span-2 sm:col-span-4">
                                        <label className="flex items-center gap-1 text-xs text-gray-500 font-bold mb-1"><Icons.MapPin size={12} /> 場所</label>
                                        <div className="flex flex-col gap-3">
                                            <div>
                                                <div className="text-xs font-semibold text-gray-600 mb-2">
                                                    この日の開催競馬場
                                                </div>
                                                <div className="course-buttons-row flex flex-nowrap gap-2 pill-group w-full">
                                                    {activeCourses.length === 0 && (
                                                        <span className="text-xs text-gray-400">
                                                            開催情報が取得できなかったため、開催ボタンを表示できませんでした。
                                                        </span>
                                                    )}
                                                    {activeCourses.map((course) => {
                                                        const name = typeof course === 'string'
                                                            ? course
                                                            : (course.name || course.label || course.id);
                                                        const isActive = selectedCourse === name;

                                                        return (
                                                            <button
                                                                key={name}
                                                                type="button"
                                                                onClick={() => setSelectedCourse(name)}
                                                                className={
                                                                    'pill-button text-sm font-semibold flex-1 min-w-0 ' +
                                                                    (isActive
                                                                        ? 'pill-active bg-emerald-600 text-white border-emerald-600'
                                                                        : 'bg-white text-emerald-700 border-emerald-300 hover:bg-emerald-50')
                                                                }
                                                            >
                                                                {name}
                                                            </button>
                                                        );
                                                    })}
                                                </div>
                                            </div>
                                        </div>
                                        {isScheduleMissingForDate && (
                                            <p className="text-[10px] text-gray-400 mt-1">開催情報が見つからないため、全競馬場を表示しています。</p>
                                        )}
                                    </div>
                                    <div className="col-span-2 sm:col-span-3">
                                        <label className="flex items-center gap-1 text-xs text-gray-500 font-bold mb-1"><Icons.Flag size={12} /> R</label>
                                        <div className="flex flex-col gap-3">
                                            <div>
                                                <div className="text-xs font-semibold text-gray-600 mb-2">
                                                    レース番号
                                                </div>
                                                <div className="flex flex-col gap-3">
                                                    <div className="grid grid-cols-6 gap-2">
                                                        {TOP_RACE_NUMBERS.map(renderRaceButton)}
                                                    </div>
                                                    <div className="grid grid-cols-6 gap-2">
                                                        {BOTTOM_RACE_NUMBERS.map(renderRaceButton)}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div className="col-span-2 sm:col-span-3">
                                        <label className="flex items-center gap-1 text-xs text-gray-500 font-bold mb-1"><Icons.Star size={12} /> 自信度</label>
                                        <div className="confidence-buttons">
                                            {CONFIDENCE_LEVELS.map((level) => {
                                                const isActive = raceMeta.confidence === level.value;

                                                return (
                                                    <button
                                                        key={level.value}
                                                        type="button"
                                                        onClick={() => handleConfidenceClick(level.value)}
                                                        className={
                                                            'pill-button text-sm font-semibold h-12 flex-1 min-w-0 flex items-center justify-center whitespace-nowrap ' +
                                                            (isActive
                                                                ? 'pill-active bg-amber-500 text-white border-amber-500'
                                                                : 'bg-white text-amber-700 border-amber-300 hover:bg-amber-50')
                                                        }
                                                    >
                                                        {level.label}
                                                    </button>
                                                );
                                            })}
                                        </div>
                                    </div>
                                    <div className="col-span-2 sm:col-span-3">
                                        <label className="flex items-center gap-1 text-xs text-gray-500 font-bold mb-1"><Icons.Lightbulb size={12} /> 根拠</label>
                                        <div className="basis-buttons grid grid-cols-3 gap-3">
                                            {ORDERED_REASON_TAGS.map((tag) => {
                                                const isActive = raceMeta.strategy === tag.value;

                                                return (
                                                    <button
                                                        key={tag.value}
                                                        type="button"
                                                        onClick={() => handleStrategyClick(tag.value)}
                                                        className={
                                                            'pill-button text-sm font-semibold min-w-[120px] h-12 w-full flex items-center justify-center whitespace-nowrap ' +
                                                            (isActive
                                                                ? 'pill-active bg-sky-600 text-white border-sky-600'
                                                                : 'bg-white text-sky-700 border-sky-300 hover:bg-sky-50')
                                                        }
                                                    >
                                                        {tag.label}
                                                    </button>
                                                );
                                            })}
                                        </div>
                                    </div>
                                    <div className="col-span-2 sm:col-span-3"><label className="flex items-center gap-1 text-xs text-gray-500 font-bold mb-1"><Icons.FileText size={12} /> メモ</label><input type="text" placeholder="レース名など" value={raceMeta.note} onChange={(e) => setRaceMeta(prev => ({ ...prev, note: e.target.value }))} className="w-full text-sm border-gray-300 rounded border p-1.5" /></div>
                                </div>
                            </section>

                            <section className="w-full bg-white border-b border-slate-200 relative">
                                <div className="px-3 sm:px-4 py-3 bg-gray-50 border-b flex justify-between items-center"><h2 className="font-bold text-gray-700 section-title flex items-center gap-2"><Icons.Settings size={18}/> 買い目作成</h2><button onClick={clearSelection} className="text-xs text-gray-500 hover:text-red-500 underline">選択クリア</button></div>
                                <div className="px-3 sm:px-4 py-4 space-y-3 border-b border-gray-100">
                                    <div className="flex flex-col sm:flex-row gap-3">
                                        <div className="flex-1">
                                            <label className="block text-xs font-bold text-gray-500 mb-1">式別</label>
                                            <div className="grid grid-cols-4 gap-3">
                                                {orderedTicketTypes.slice(0, 4).map((type) => renderTicketButton(type))}
                                            </div>
                                            <div className="grid grid-cols-3 gap-3 mt-3">
                                                {orderedTicketTypes.slice(4).map((type) => renderTicketButton(type))}
                                            </div>
                                        </div>
                                        <div className="flex-1"><label className="block text-xs font-bold text-gray-500 mb-1">方式</label><div className="flex bg-gray-200 rounded p-1 voting-toggle">{!isSingleHorseBet && (<><button onClick={() => setVotingMode('nagashi')} className={`flex-1 flex items-center justify-center gap-1 text-xs py-1.5 rounded transition-all ${votingMode === 'nagashi' ? 'bg-white text-emerald-700 shadow font-bold' : 'text-gray-500'}`}><Icons.GitMerge size={14} className="rotate-90" /> 流し</button><button onClick={() => setVotingMode('formation')} className={`flex-1 flex items-center justify-center gap-1 text-xs py-1.5 rounded transition-all ${votingMode === 'formation' ? 'bg-white text-emerald-700 shadow font-bold' : 'text-gray-500'}`}><Icons.Layers size={14} /> フォーメ</button></>)}<button onClick={() => setVotingMode('box')} className={`flex-1 flex items-center justify-center gap-1 text-xs py-1.5 rounded transition-all ${votingMode === 'box' ? 'bg-white text-emerald-700 shadow font-bold' : 'text-gray-500'}`}><Icons.CheckSquare size={14} /> {isSingleHorseBet ? '通常' : 'BOX'}</button></div></div>
                                    </div>
                                </div>
                                <div className="px-3 sm:px-4 py-4">
                                    {votingMode === 'box' && (<><div className="mb-2 text-xs text-center text-gray-500">{isSingleHorseBet ? '馬を選択してください（複数選択可）' : 'ボックス買いする馬を選択してください'}</div><div className="grid grid-cols-6 sm:grid-cols-9 gap-1.5">{Array.from({ length: horseCount }, (_, i) => i + 1).map(num => { const isSelected = boxHorses.includes(num); return renderHorseButton(num, isSelected, 'bg-emerald-600 border-emerald-700', () => toggleBoxHorse(num)); })}</div></>)}
                                    {votingMode === 'nagashi' && !isSingleHorseBet && (<><div className="mb-2 text-xs text-center text-gray-500">軸(ピンク)1頭 → 相手(青)を選択</div><div className="grid grid-cols-6 sm:grid-cols-9 gap-1.5">{Array.from({ length: horseCount }, (_, i) => i + 1).map(num => { const isAxis = axisHorse === num; const isOpp = opponentHorses.includes(num); const color = isAxis ? 'bg-pink-500 border-pink-600' : 'bg-blue-500 border-blue-600'; return renderHorseButton(num, isAxis || isOpp, color, () => handleNagashiClick(num)); })}</div></>)}
                                    {votingMode === 'formation' && !isSingleHorseBet && (
                                        <div className="space-y-4">
                                            <div><div className="flex items-center gap-2 mb-1"><span className="bg-pink-100 text-pink-800 text-xs font-bold px-2 py-0.5 rounded border border-pink-200">{getRowLabel(1, betType)}</span></div><div className="grid grid-cols-9 gap-1">{Array.from({ length: horseCount }, (_, i) => i + 1).map(num => renderHorseButton(num, formation.first.includes(num), 'bg-pink-500 border-pink-600', () => toggleFormationHorse('first', num)))}</div></div>
                                            <div><div className="flex items-center gap-2 mb-1"><span className="bg-blue-100 text-blue-800 text-xs font-bold px-2 py-0.5 rounded border border-blue-200">{getRowLabel(2, betType)}</span></div><div className="grid grid-cols-9 gap-1">{Array.from({ length: horseCount }, (_, i) => i + 1).map(num => renderHorseButton(num, formation.second.includes(num), 'bg-blue-500 border-blue-600', () => toggleFormationHorse('second', num)))}</div></div>
                                            {(betType === 'sanrenpuku' || betType === 'sanrentan') && (<div><div className="flex items-center gap-2 mb-1"><span className="bg-green-100 text-green-800 text-xs font-bold px-2 py-0.5 rounded border border-green-200">{getRowLabel(3, betType)}</span></div><div className="grid grid-cols-9 gap-1">{Array.from({ length: horseCount }, (_, i) => i + 1).map(num => renderHorseButton(num, formation.third.includes(num), 'bg-green-500 border-green-600', () => toggleFormationHorse('third', num)))}</div></div>)}
                                        </div>
                                    )}
                                </div>
                                <div className="px-3 sm:px-4 py-4 bg-gray-50 border-t flex flex-col items-center">
                                    <div className="text-sm font-bold text-gray-700 mb-2">現在の選択: <span className="text-emerald-600 text-lg">{previewCombinations.length}</span> 点</div>
                                    <button onClick={addBetsToList} disabled={previewCombinations.length === 0} className={`w-full sm:w-auto px-8 py-3 rounded-full font-bold flex items-center justify-center gap-2 shadow-lg transition-transform active:scale-95 ${previewCombinations.length > 0 ? 'bg-emerald-600 text-white hover:bg-emerald-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}><Icons.PlusCircle size={20} /> 下のリストに追加</button>
                                </div>
                            </section>

                            {betList.length > 0 && (
                                <section className="w-full bg-white border-b border-slate-200 px-3 py-5 sm:px-4 border-l-4 border-yellow-400">
                                    <div className="mb-4 flex items-center gap-4 pb-3 border-b">
                                        <span className="text-xs font-bold text-gray-500 uppercase">入力モード:</span>
                                        <div className="flex gap-3">
                                            <label className="flex items-center gap-2 cursor-pointer"><input type="radio" name="budgetMode" value="budget" checked={budgetInputMode === 'budget'} onChange={(e) => { setBudgetInputMode(e.target.value); setTargetError(null); }} className="w-4 h-4 text-emerald-600" /><span className="text-sm font-medium text-gray-700">予算から計算</span></label>
                                            <label className="flex items-center gap-2 cursor-pointer"><input type="radio" name="budgetMode" value="target" checked={budgetInputMode === 'target'} onChange={(e) => { setBudgetInputMode(e.target.value); setAllocationMode('profit'); setTargetError(null); }} className="w-4 h-4 text-blue-600" /><span className="text-sm font-medium text-gray-700">目標利益から計算</span></label>
                                        </div>
                                    </div>

                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <div>
                                            {budgetInputMode === 'budget' ? (
                                                <>
                                                    <label className="block text-xs font-bold text-gray-500 uppercase mb-1">総予算</label>
                                                    <div className="flex items-center gap-2">
                                                        <input 
                                                            type="number" 
                                                            value={totalBudget} 
                                                            onChange={(e) => setTotalBudget(e.target.value === '' ? '' : parseInt(e.target.value))} 
                                                            className="w-full border border-gray-300 rounded p-2 text-right font-mono text-lg focus:ring-2 focus:ring-emerald-500 outline-none" 
                                                            step="100" 
                                                            inputMode="numeric" 
                                                            placeholder="0"
                                                        />
                                                        <span className="text-gray-500 text-sm">円</span>
                                                    </div>
                                                </>
                                            ) : (
                                                <>
                                                    <label className="block text-xs font-bold text-blue-600 uppercase mb-1">目標利益</label>
                                                    <div className="flex flex-col gap-2">
                                                        <div className="flex items-center gap-2">
                                                            <input 
                                                                type="number" 
                                                                value={targetProfit} 
                                                                onChange={(e) => setTargetProfit(e.target.value === '' ? '' : parseInt(e.target.value))} 
                                                                className="w-full border border-blue-300 rounded p-2 text-right font-mono text-lg focus:ring-2 focus:ring-blue-500 outline-none" 
                                                                step="100" 
                                                                inputMode="numeric" 
                                                                placeholder="0"
                                                            />
                                                            <span className="text-gray-500 text-sm">円</span>
                                                        </div>
                                                        <button onClick={calculateBudgetFromTarget} className="w-full bg-blue-600 text-white py-2 rounded font-bold text-sm hover:bg-blue-700 transition-colors flex items-center justify-center gap-2"><Icons.Calculator size={16} /> 必要予算を計算</button>
                                                        {targetError && (<div className="bg-red-50 border border-red-200 text-red-700 px-3 py-2 rounded text-xs">{targetError}</div>)}
                                                        {!targetError && budgetInputMode === 'target' && (
                                                            <div className="bg-blue-50 border border-blue-200 text-blue-700 px-3 py-2 rounded text-xs">
                                                                <strong>必要予算:</strong> {totalBudget.toLocaleString()}円
                                                            </div>
                                                        )}
                                                    </div>
                                                </>
                                            )}
                                        </div>

                                        <div className="flex flex-col justify-between">
                                            <div className="flex justify-between text-sm mb-1"><span className="text-gray-600">買い目合計:</span><span className="font-bold">{stats.count} 点</span></div>
                                            <div className="flex justify-between text-sm mb-1"><span className="text-gray-600">投資総額:</span><span className={`font-bold ${stats.totalStake > (totalBudget === '' ? 0 : parseInt(totalBudget)) ? 'text-red-500' : 'text-emerald-600'}`}>{stats.totalStake.toLocaleString()} 円</span></div>
                                        </div>
                                    </div>

                                    <EffectiveOddsPanel bets={effectiveOddsBets} />

                                    <div className="mt-3 flex items-center gap-2">
                                        <input
                                            type="number"
                                            min="1"
                                            max="90"
                                            value={whatIfRate}
                                            onChange={(e) => setWhatIfRate(Number(e.target.value))}
                                            className="w-20 px-2 py-1 border rounded text-sm"
                                        />
                                        <span className="text-sm">％オッズが下がった場合の損益を見る</span>
                                    </div>

                                    <button
                                        type="button"
                                        onClick={handleWhatIfToggle}
                                        aria-expanded={showWhatIfResult}
                                        className={`mt-2 w-full bg-amber-50 hover:bg-amber-100 text-amber-800 text-xs font-bold py-2 rounded-lg border border-amber-300 flex items-center justify-center gap-2 transition-colors ${showWhatIfResult ? 'ring-2 ring-amber-200' : ''}`}
                                    >
                                        <Icons.AlertCircle size={14} />
                                        オッズが {whatIfRate}% 下がった場合の損益をシミュレーション
                                        {showWhatIfResult ? <Icons.ChevronUp size={14} /> : <Icons.ChevronDown size={14} />}
                                    </button>

                                    {showWhatIfResult && <WhatIfResultPanel result={whatIfResult} />}

                                    <div className="mt-4 flex gap-2">
                                        <button onClick={() => { setAllocationMode('profit'); setCustomStakes({}); }} className={`flex-1 text-xs py-2 rounded border ${allocationMode === 'profit' ? 'bg-emerald-100 border-emerald-500 text-emerald-800 font-bold' : 'bg-white text-gray-600'}`}>払戻均等 (利益確保){budgetInputMode === 'target' && <span className="block text-[10px] text-emerald-600 mt-0.5">目標利益モード使用中</span>}</button>
                                        <button onClick={() => { if (budgetInputMode !== 'target') { setAllocationMode('flat'); setCustomStakes({}); } }} disabled={budgetInputMode === 'target'} className={`flex-1 text-xs py-2 rounded border ${budgetInputMode === 'target' ? 'bg-gray-100 text-gray-400 cursor-not-allowed' : allocationMode === 'flat' ? 'bg-emerald-100 border-emerald-500 text-emerald-800 font-bold' : 'bg-white text-gray-600'}`}>資金均等 (一律){budgetInputMode === 'target' && <span className="block text-[10px] text-gray-400 mt-0.5">利益モードでは無効</span>}</button>
                                    </div>
                                </section>
                            )}

                            {betList.length > 0 ? (
                                <section id="bet-list-section" className="bg-white rounded-lg shadow overflow-hidden">
                                    <div className="bg-gray-50 p-3 border-b flex justify-between items-center">
                                        <h3 className="font-bold text-gray-700 flex items-center gap-2">
                                            <Icons.Save size={18} /> 
                                            買い目リスト ({betList.length}点)
                                        </h3>
                                    </div>
                                    
                                    <div className="overflow-x-auto max-h-[600px]">
                                        <table className="w-full text-sm text-left relative">
                                            <thead className="bg-gray-100 text-gray-600 text-xs uppercase sticky top-0 z-10 shadow-sm">
                                                <tr>
                                                    <th className="p-1.5 sm:p-3">式別/組合せ</th>
                                                    <th className="p-1.5 sm:p-3 text-center">オッズ</th>
                                                    <th className="p-1.5 sm:p-3 text-right">投資額</th>
                                                    <th className="p-1.5 sm:p-3 text-right hidden sm:table-cell">予想払戻</th>
                                                    <th className="p-1.5 sm:p-3 w-8 sm:w-10"></th>
                                                </tr>
                                            </thead>
                                            <tbody className="divide-y divide-gray-100">
                                                {betList.map((bet) => {
                                                    const betData = calculatedData.find(row => row.key === bet.key);
                                                    
                                                    return (
                                                        <tr key={bet.key} className="hover:bg-emerald-50 transition-colors">
                                                            <td className="p-1.5 sm:p-3">
                                                                <div className="flex flex-col">
                                                                    <span className="text-[9px] sm:text-[10px] text-gray-400 font-bold uppercase tracking-wider">{getTypeName(bet.type)}</span>
                                                                    <span className="font-mono font-bold text-gray-700 text-sm sm:text-lg">{bet.label}</span>
                                                                </div>
                                                            </td>
                                                            <td className="p-1.5 sm:p-3 text-center">
                                                                <input 
                                                                    type="number" 
                                                                    step="0.1" 
                                                                    placeholder="0.0" 
                                                                    value={oddsData[bet.key] || ''} 
                                                                    onChange={(e) => handleOddsChange(bet.key, e.target.value)} 
                                                                    className="w-16 border border-gray-300 rounded px-1 py-1 text-base sm:text-sm text-right focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 outline-none" 
                                                                    inputMode="decimal" 
                                                                />
                                                            </td>
                                                            <td className="p-1.5 sm:p-3 text-right font-mono">
                                                                {betData?.stake >= 0 ? (
                                                                    <div className="flex flex-col items-end gap-1">
                                                                        <input 
                                                                            type="number" 
                                                                            step="100" 
                                                                            value={customStakes[bet.key] !== undefined ? customStakes[bet.key] : (betData.stake || '')} 
                                                                            onChange={(e) => handleStakeChange(bet.key, e.target.value)} 
                                                                            className="w-20 sm:w-24 bg-emerald-100 text-emerald-800 px-1.5 sm:px-2 py-0.5 sm:py-1 rounded text-xs sm:text-sm text-right border border-emerald-300 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 outline-none font-mono" 
                                                                            inputMode="numeric" 
                                                                            placeholder="0"
                                                                        />
                                                                        <div className="sm:hidden flex flex-col items-end text-[10px]"><span className="font-bold">{betData.return.toLocaleString()}</span><span className={betData.profit >= 0 ? 'text-emerald-600' : 'text-red-500'}>{betData.profit >= 0 ? '+' : ''}{betData.profit.toLocaleString()}</span></div>
                                                                    </div>
                                                                ) : '-'}
                                                            </td>
                                                            <td className="p-1.5 sm:p-3 text-right hidden sm:table-cell">
                                                                {betData?.stake > 0 ? (
                                                                    <div className="flex flex-col items-end">
                                                                        <span className="font-bold">{betData.return.toLocaleString()}</span>
                                                                        <span className={`text-xs ${betData.profit >= 0 ? 'text-emerald-600' : 'text-red-500'}`}>
                                                                            {betData.profit >= 0 ? '+' : ''}{betData.profit.toLocaleString()}
                                                                        </span>
                                                                    </div>
                                                                ) : '-'}
                                                            </td>
                                                            <td className="p-1.5 sm:p-3 text-right">
                                                                <button 
                                                                    onClick={() => removeBet(bet.key)} 
                                                                    className="text-gray-400 hover:text-red-500 transition-colors"
                                                                >
                                                                    <Icons.Trash2 size={14} className="sm:hidden" />
                                                                    <Icons.Trash2 size={16} className="hidden sm:block" />
                                                                </button>
                                                            </td>
                                                        </tr>
                                                    );
                                                })}
                                            </tbody>
                                        </table>
                                    </div>

                                    <div className="p-4 bg-gray-50 border-t">
                                        <div className="flex gap-3 mb-4">
                                            <button 
                                                onClick={saveToHistory}
                                                className="flex-1 bg-blue-600 text-white font-bold py-3 rounded-lg shadow hover:bg-blue-700 flex items-center justify-center gap-2"
                                            >
                                                <Icons.Save size={20} />
                                                買い目を保存
                                            </button>
                                            <button 
                                                onClick={() => setShowResultInput(!showResultInput)} 
                                                className={`flex-1 font-bold py-3 rounded-lg shadow flex items-center justify-center gap-2 transition-colors ${
                                                    showResultInput 
                                                    ? 'bg-purple-600 text-white hover:bg-purple-700' 
                                                    : 'bg-white text-purple-600 border border-purple-200 hover:bg-purple-50'
                                                }`}
                                            >
                                                <Icons.Award size={20} /> 
                                                的中判定
                                            </button>
                                        </div>
                                        
                                        {showResultInput && (
                                            <div className="p-4 bg-purple-50 rounded-lg border-2 border-purple-200 animate-slide-in">
                                                <h4 className="font-bold text-purple-900 mb-3 flex items-center gap-2"><Icons.Award size={16} /> レース結果を入力</h4>
                                                <div className="grid grid-cols-3 gap-3 mb-3">
                                                    <div><label className="text-xs text-purple-700 font-semibold block mb-1">1着</label><input type="number" min="1" max={horseCount} value={raceResult.first} onChange={(e) => setRaceResult(prev => ({ ...prev, first: e.target.value }))} className="w-full border border-purple-300 rounded px-2 py-2 text-center text-base focus:border-purple-500 focus:ring-1 focus:ring-purple-500 outline-none" placeholder="馬番" inputMode="numeric" /></div>
                                                    <div><label className="text-xs text-purple-700 font-semibold block mb-1">2着</label><input type="number" min="1" max={horseCount} value={raceResult.second} onChange={(e) => setRaceResult(prev => ({ ...prev, second: e.target.value }))} className="w-full border border-purple-300 rounded px-2 py-2 text-center text-base focus:border-purple-500 focus:ring-1 focus:ring-purple-500 outline-none" placeholder="馬番" inputMode="numeric" /></div>
                                                    <div><label className="text-xs text-purple-700 font-semibold block mb-1">3着</label><input type="number" min="1" max={horseCount} value={raceResult.third} onChange={(e) => setRaceResult(prev => ({ ...prev, third: e.target.value }))} className="w-full border border-purple-300 rounded px-2 py-2 text-center text-base focus:border-purple-500 focus:ring-1 focus:ring-purple-500 outline-none" placeholder="馬番" inputMode="numeric" /></div>
                                                </div>
                                                <div className="mb-3">
                                                    <label className="text-xs text-purple-700 font-semibold block mb-1 flex items-center gap-1">
                                                        <Icons.FileText size={14} />
                                                        反省ノート
                                                    </label>
                                                    <textarea
                                                        value={reflectionNoteInput}
                                                        onChange={(e) => setReflectionNoteInput(e.target.value)}
                                                        className="w-full border border-purple-300 rounded px-3 py-2 text-sm focus:border-purple-500 focus:ring-1 focus:ring-purple-500 outline-none resize-none"
                                                        rows="3"
                                                        placeholder="当たり外れの反省、気づいたこと、次回への改善点などをメモ..."
                                                    />
                                                </div>
                                                <button onClick={checkResults} className="w-full bg-purple-600 text-white font-bold py-2 rounded-lg hover:bg-purple-700 flex items-center justify-center gap-2 shadow"><Icons.Award size={18} /> 判定を実行</button>
                                            </div>
                                        )}
                                    </div>
                                </section>
                            ) : (
                                <div className="text-center py-12 text-gray-400 bg-white rounded-lg border-2 border-dashed border-gray-200">
                                    <Icons.Info className="mx-auto mb-2 opacity-50" />
                                    <p>まだ買い目がありません</p>
                                    <p className="text-xs mt-1">馬を選んで「下のリストに追加」を押してください</p>
                                </div>
                            )}
                        </main>
                    )}

                    {currentView === 'history' && (
                        <main className="w-full px-3 sm:px-4 pt-4 pb-10 app-main">
                            <div className="flex items-center gap-2 mb-4"><button onClick={() => setCurrentView('calculator')} className="p-2 bg-white rounded-full shadow hover:bg-gray-100"><Icons.ArrowLeft size={20} className="text-gray-600" /></button><h2 className="text-xl font-bold text-gray-700">買い目</h2></div>
                            {savedHistory.length === 0 ? (<div className="w-full text-center py-12 text-gray-400 bg-white border border-dashed border-gray-200"><Icons.History className="mx-auto mb-2 opacity-50" size={48} /><p>保存された買い目はありません</p></div>) : (
                                <div className="flex flex-col">
                                    {savedHistory.map((entry) => {
                                        const betCount = entry.data.betList?.length || 0;
                                        const hasOdds = entry.data.oddsData && Object.keys(entry.data.oddsData).length > 0;
                                        const strategyKey = entry.meta.strategy || 'data';
                                        const strategy = STRATEGIES[strategyKey] || STRATEGIES.data;
                                        const confidenceKey = entry.meta.confidence || 'A';
                                        const confidence = CONFIDENCES[confidenceKey] || CONFIDENCES.A;

                                        return (
                                            <div key={entry.id} className="w-full bg-white border-b border-slate-200 px-3 py-4 sm:px-4 border-l-4 border-blue-500 last:border-b-0">
                                                <div className="flex justify-between items-start mb-3">
                                                    <div className="flex-1">
                                                        <div className="flex items-center gap-2 mb-1">
                                                            <span className="font-bold text-lg text-gray-800">{entry.meta.place} {entry.meta.raceNum}R</span>
                                                            <span className={`text-[10px] px-1.5 py-0.5 rounded border ${strategy.color.replace('focus:ring-', '')}`}>
                                                                {getReasonLabel(strategy.id)}
                                                            </span>
                                                            <span className={`text-[10px] px-1.5 py-0.5 rounded border ${confidence.color.replace('bg-', 'bg-opacity-10 bg-').replace('text-', 'text-opacity-90 text-')}`}>
                                                                {confidence.label}
                                                            </span>
                                                        </div>
                                                        <span className="text-xs bg-gray-100 text-gray-600 px-2 py-0.5 rounded border">{formatDateDisplay(entry.meta.date)}</span>
                                                        {entry.meta.note && (<p className="text-sm text-gray-500 flex items-center gap-1 mt-1"><Icons.FileText size={12} /> {entry.meta.note}</p>)}
                                                    </div>
                                                    <div className="text-right"><span className="block text-xs text-gray-500">予算</span><span className="font-bold text-emerald-600">{parseInt(entry.data.totalBudget).toLocaleString()}円</span></div>
                                                </div>
                                                
                                                <div className="grid grid-cols-2 gap-2 text-xs mb-3"><div className="bg-gray-50 p-2 rounded"><span className="text-gray-500">買い目:</span><span className="font-bold ml-1">{betCount}点</span></div><div className="bg-gray-50 p-2 rounded"><span className="text-gray-500">モード:</span><span className="font-bold ml-1">{entry.data.allocationMode === 'profit' ? '払戻均等' : '資金均等'}</span></div></div>
                                                {hasOdds && (<div className="text-xs text-blue-600 bg-blue-50 p-2 rounded mb-3">✓ オッズデータ保存済み</div>)}
                                                <div className="flex gap-2"><button onClick={() => loadFromHistory(entry)} className="flex-1 bg-emerald-600 text-white py-2 rounded text-sm font-bold hover:bg-emerald-700 flex items-center justify-center gap-1"><Icons.RefreshCw size={14} /> 読み込む</button><button onClick={() => deleteHistoryItem(entry.id)} className="px-3 bg-white border border-gray-300 text-gray-500 rounded hover:bg-red-50 hover:text-red-500 hover:border-red-300"><Icons.Trash2 size={16} /></button></div>
                                            </div>
                                        );
                                    })}
                                </div>
                            )}
                        </main>
                    )}

                    {currentView === 'results' && (
                        <main className="w-full px-3 sm:px-4 pt-4 pb-10 app-main">
                            <div className="flex items-center justify-between mb-4">
                                <div className="flex items-center gap-2">
                                    <button onClick={() => setCurrentView('calculator')} className="p-2 bg-white rounded-full shadow hover:bg-gray-100"><Icons.ArrowLeft size={20} className="text-gray-600" /></button>
                                    <h2 className="text-xl font-bold text-gray-700">的中判定結果</h2>
                                </div>
                                {resultHistory.length > 0 && (
                                    <button onClick={clearStats} className="text-xs bg-red-50 text-red-600 px-3 py-1.5 rounded border border-red-200 hover:bg-red-100 flex items-center gap-1 transition-colors">
                                        <Icons.Trash2 size={14} />
                                        データ削除
                                    </button>
                                )}
                            </div>
                            {resultHistory.length === 0 ? (<div className="w-full text-center py-12 text-gray-400 bg-white border border-dashed border-gray-200"><Icons.BarChart className="mx-auto mb-2 opacity-50" size={48} /><p>まだ的中判定の記録がありません</p><p className="text-xs mt-1">レースの結果を入力して記録を蓄積しましょう</p></div>) : (
                                <div className="flex flex-col">
                                    <div className="w-full bg-white border-b border-slate-200 px-3 py-5 sm:px-4"><h3 className="font-bold text-gray-700 mb-3 flex items-center gap-2"><Icons.TrendingUp size={18} /> 全体成績</h3><div className="grid grid-cols-2 gap-4"><div className="bg-blue-50 p-3 rounded"><div className="text-xs text-blue-600 mb-1">総レース数</div><div className="text-2xl font-bold text-blue-900">{resultHistory.length}</div></div><div className="bg-green-50 p-3 rounded"><div className="text-xs text-green-600 mb-1">的中率</div><div className="text-2xl font-bold text-green-900">{resultHistory.length > 0 ? ((resultHistory.filter(r => r.winCount > 0).length / resultHistory.length) * 100).toFixed(1) : 0}%</div></div><div className="bg-purple-50 p-3 rounded"><div className="text-xs text-purple-600 mb-1">総投資額</div><div className="text-2xl font-bold text-purple-900">{resultHistory.reduce((sum, r) => sum + r.totalInvested, 0).toLocaleString()}円</div></div><div className={`p-3 rounded ${resultHistory.reduce((sum, r) => sum + r.profit, 0) >= 0 ? 'bg-emerald-50' : 'bg-red-50'}`}><div className={`text-xs mb-1 ${resultHistory.reduce((sum, r) => sum + r.profit, 0) >= 0 ? 'text-emerald-600' : 'text-red-600'}`}>総収支</div><div className={`text-2xl font-bold ${resultHistory.reduce((sum, r) => sum + r.profit, 0) >= 0 ? 'text-emerald-900' : 'text-red-900'}`}>{resultHistory.reduce((sum, r) => sum + r.profit, 0) >= 0 ? '+' : ''}{resultHistory.reduce((sum, r) => sum + r.profit, 0).toLocaleString()}円</div></div><div className="bg-yellow-50 p-3 rounded col-span-2"><div className="text-xs text-yellow-600 mb-1">回収率</div><div className="text-2xl font-bold text-yellow-900">{resultHistory.reduce((sum, r) => sum + r.totalInvested, 0) > 0 ? ((resultHistory.reduce((sum, r) => sum + r.totalReturn, 0) / resultHistory.reduce((sum, r) => sum + r.totalInvested, 0)) * 100).toFixed(1) : 0}%</div></div></div></div>
                                    <ZoneStatsPanel records={resultHistory} />

                                    {/* 根拠別成績 (Added Section) */}
                                    <div className="w-full bg-white border-b border-slate-200 px-3 py-5 sm:px-4">
                                        <h3 className="font-bold text-gray-700 mb-3 flex items-center gap-2"><Icons.Lightbulb size={18} /> 根拠別成績</h3>
                                        <div className="space-y-2">
                                            {Object.entries(resultHistory.reduce((acc, r) => {
                                                const s = r.strategy || 'data';
                                                if (!acc[s]) {
                                                    acc[s] = { count: 0, wins: 0, invested: 0, returned: 0, profit: 0 };
                                                }
                                                acc[s].count++;
                                                if (r.winCount > 0) acc[s].wins++;
                                                acc[s].invested += r.totalInvested;
                                                acc[s].returned += r.totalReturn;
                                                acc[s].profit += r.profit;
                                                return acc;
                                            }, {})).map(([key, stats]) => {
                                                const strategy = STRATEGIES[key] || STRATEGIES.data;
                                                const winRate = ((stats.wins / stats.count) * 100).toFixed(1);
                                                const returnRate = stats.invested > 0 ? ((stats.returned / stats.invested) * 100).toFixed(1) : 0;
                                                
                                                return (
                                                    <div key={key} className={`flex items-center justify-between p-2 rounded border-l-4 ${strategy.color.replace('bg-', 'border-').replace('text-', '').split(' ')[0]} bg-gray-50`}>
                                                        <div className="flex-1">
                                                            <div className="flex items-center gap-2">
                                                                <span className={`text-xs font-bold px-2 py-0.5 rounded ${strategy.color.replace('focus:ring-', '')}`}>
                                                                    {getReasonLabel(strategy.id)}
                                                                </span>
                                                                <span className="text-xs text-gray-500">{stats.count}レース / 的中{stats.wins}</span>
                                                            </div>
                                                            <div className="text-xs text-gray-500 mt-1">
                                                                的中率 {winRate}% / 回収率 {returnRate}%
                                                            </div>
                                                        </div>
                                                        <div className="text-right">
                                                            <div className={`font-bold ${stats.profit >= 0 ? 'text-emerald-600' : 'text-red-600'}`}>
                                                                {stats.profit >= 0 ? '+' : ''}{stats.profit.toLocaleString()}円
                                                            </div>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>

                                    {/* 自信度別成績 (New) */}
                                    <div className="w-full bg-white border-b border-slate-200 px-3 py-5 sm:px-4">
                                        <h3 className="font-bold text-gray-700 mb-3 flex items-center gap-2"><Icons.Star size={18} /> 自信度別成績</h3>
                                        <div className="space-y-2">
                                            {Object.entries(resultHistory.reduce((acc, r) => {
                                                const c = r.confidence || 'A';
                                                if (!acc[c]) {
                                                    acc[c] = { count: 0, wins: 0, invested: 0, returned: 0, profit: 0 };
                                                }
                                                acc[c].count++;
                                                if (r.winCount > 0) acc[c].wins++;
                                                acc[c].invested += r.totalInvested;
                                                acc[c].returned += r.totalReturn;
                                                acc[c].profit += r.profit;
                                                return acc;
                                            }, {})).sort().map(([key, stats]) => {
                                                const conf = CONFIDENCES[key] || CONFIDENCES.A;
                                                const winRate = ((stats.wins / stats.count) * 100).toFixed(1);
                                                const returnRate = stats.invested > 0 ? ((stats.returned / stats.invested) * 100).toFixed(1) : 0;
                                                
                                                // Determine border color based on text color
                                                const borderColorClass = conf.color.split(' ').find(c => c.startsWith('text-')).replace('text-', 'border-');

                                                return (
                                                    <div key={key} className={`flex items-center justify-between p-2 rounded border-l-4 ${borderColorClass} bg-gray-50`}>
                                                        <div className="flex-1">
                                                            <div className="flex items-center gap-2">
                                                                <span className={`text-xs font-bold px-2 py-0.5 rounded ${conf.color.replace('text-', 'text-opacity-90 text-').replace('bg-', 'bg-opacity-10 bg-')}`}>
                                                                    {conf.fullLabel}
                                                                </span>
                                                                <span className="text-xs text-gray-500">{stats.count}レース / 的中{stats.wins}</span>
                                                            </div>
                                                            <div className="text-xs text-gray-500 mt-1">
                                                                的中率 {winRate}% / 回収率 {returnRate}%
                                                            </div>
                                                        </div>
                                                        <div className="text-right">
                                                            <div className={`font-bold ${stats.profit >= 0 ? 'text-emerald-600' : 'text-red-600'}`}>
                                                                {stats.profit >= 0 ? '+' : ''}{stats.profit.toLocaleString()}円
                                                            </div>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>

                                    <div className="bg-white rounded-lg shadow p-4"><h3 className="font-bold text-gray-700 mb-3">競馬場別成績</h3><div className="space-y-2">{Object.entries(resultHistory.reduce((acc, r) => { if (!acc[r.place]) { acc[r.place] = { count: 0, invested: 0, returned: 0, profit: 0 }; } acc[r.place].count++; acc[r.place].invested += r.totalInvested; acc[r.place].returned += r.totalReturn; acc[r.place].profit += r.profit; return acc; }, {})).map(([place, stats]) => (<div key={place} className="flex items-center justify-between p-2 bg-gray-50 rounded"><div className="flex-1"><div className="font-semibold">{place}</div><div className="text-xs text-gray-500">{stats.count}レース</div></div><div className="text-right"><div className={`font-bold ${stats.profit >= 0 ? 'text-emerald-600' : 'text-red-600'}`}>{stats.profit >= 0 ? '+' : ''}{stats.profit.toLocaleString()}円</div><div className="text-xs text-gray-500">回収率 {((stats.returned / stats.invested) * 100).toFixed(1)}%</div></div></div>))}</div></div>
                                    <div className="bg-white rounded-lg shadow p-4">
                                        <h3 className="font-bold text-gray-700 mb-3">式別成績</h3>
                                        <div className="space-y-2">
                                            {Object.entries(resultHistory.reduce((acc, r) => { 
                                                r.bets.forEach(bet => {
                                                    if (!acc[bet.type]) { acc[bet.type] = { count: 0, wins: 0, invested: 0, returned: 0 }; }
                                                    acc[bet.type].count++;
                                                    if (bet.isWin) {
                                                        acc[bet.type].wins++;
                                                        const effectiveOdds = bet.resultOdds ?? bet.odds;
                                                        acc[bet.type].returned += bet.stake * effectiveOdds;
                                                    }
                                                    acc[bet.type].invested += bet.stake;
                                                });
                                                return acc;
                                            }, {}))
                                            .sort(([typeA], [typeB]) => {
                                                const order = ['tansho', 'fukusho', 'wide', 'umaren', 'umatan', 'sanrenpuku', 'sanrentan'];
                                                return order.indexOf(typeA) - order.indexOf(typeB);
                                            })
                                            .map(([type, stats]) => { 
                                                const typeName = { 'tansho': '単勝', 'fukusho': '複勝', 'wide': 'ワイド', 'umaren': '馬連', 'umatan': '馬単', 'sanrenpuku': '3連複', 'sanrentan': '3連単' }[type] || type; 
                                                return (
                                                    <div key={type} className="flex items-center justify-between p-2 bg-gray-50 rounded">
                                                        <div className="flex-1">
                                                            <div className="font-semibold">{typeName}</div>
                                                            <div className="text-xs text-gray-500">{stats.count}点 / 的中{stats.wins}点 ({((stats.wins / stats.count) * 100).toFixed(1)}%)</div>
                                                        </div>
                                                        <div className="text-right">
                                                            <div className={`font-bold ${stats.returned - stats.invested >= 0 ? 'text-emerald-600' : 'text-red-600'}`}>
                                                                {stats.returned - stats.invested >= 0 ? '+' : ''}{(stats.returned - stats.invested).toLocaleString()}円
                                                            </div>
                                                            <div className="text-xs text-gray-500">回収率 {stats.invested > 0 ? ((stats.returned / stats.invested) * 100).toFixed(1) : 0}%</div>
                                                        </div>
                                                    </div>
                                                ); 
                                            })}
                                        </div>
                                    </div>
                                    <div className="bg-white rounded-lg shadow p-4"><h3 className="font-bold text-gray-700 mb-3">収支推移</h3><div className="h-48 flex items-end gap-1">{resultHistory.slice(-20).map((r, i) => { const maxProfit = Math.max(...resultHistory.slice(-20).map(r => Math.abs(r.profit))); const height = (Math.abs(r.profit) / maxProfit) * 100; return (<div key={i} className="flex-1 flex flex-col items-center group relative"><div className={`w-full rounded-t transition-all ${r.profit >= 0 ? 'bg-emerald-500' : 'bg-red-500'}`} style={{ height: `${Math.max(height, 5)}%` }}></div><div className="absolute -top-8 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs px-2 py-1 rounded opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap pointer-events-none">{r.date}<br/>{r.profit >= 0 ? '+' : ''}{r.profit.toLocaleString()}円</div></div>); })}</div><div className="text-xs text-gray-500 text-center mt-2">直近{Math.min(resultHistory.length, 20)}レースの収支</div></div>

                                    {/* レース詳細リスト */}
                                    <div>
                                        <h3 className="font-bold text-gray-700 mb-3 flex items-center gap-2"><Icons.List size={18} /> レース詳細</h3>
                                        <div className="space-y-3">
                                            {(() => {
                                                // 日付ごとにグループ化
                                                const groupedByDate = resultHistory.reduce((acc, result) => {
                                                    const date = result.date;
                                                    if (!acc[date]) {
                                                        acc[date] = [];
                                                    }
                                                    acc[date].push(result);
                                                    return acc;
                                                }, {});

                                                // 日付でソート（新しい順）
                                                const sortedDates = Object.keys(groupedByDate).sort((a, b) => b.localeCompare(a));

                                                return sortedDates.map(date => (
                                                    <DateAccordion
                                                        key={date}
                                                        date={date}
                                                        results={groupedByDate[date]}
                                                        loadFromResult={loadFromResult}
                                                        bankrollHistory={bankrollHistory}
                                                        deleteBankrollRecord={deleteBankrollRecord}
                                                    />
                                                ));
                                            })()}
                                        </div>
                                    </div>
                                </div>
                            )}
                        </main>
                    )}

                    {currentView === 'edit-result' && editingResultData && (() => {
                        const EditResultView = () => {
                            const [editedRaceResult, setEditedRaceResult] = React.useState({
                                first: editingResultData.result.first.toString(),
                                second: editingResultData.result.second.toString(),
                                third: editingResultData.result.third.toString()
                            });

                            const [reflectionNote, setReflectionNote] = React.useState(
                                editingResultData.reflectionNote || ''
                            );

                            const [editedBets, setEditedBets] = React.useState(() => {
                                return editingResultData.bets.map(bet => {
                                    const originalBet = editingResultData.originalData?.betList?.find(b => b.label === bet.combination);
                                    const purchaseOdds = originalBet
                                        ? Number(editingResultData.originalData.oddsData[originalBet.key]) || 0
                                        : Number(bet.odds) || 0;
                                    const resultOdds = bet.resultOdds ?? bet.odds ?? purchaseOdds;
                                    return {
                                        ...bet,
                                        purchaseOdds,
                                        resultOdds
                                    };
                                });
                            });

                            const handleResultOddsChange = (combination, value) => {
                                setEditedBets(prev =>
                                    prev.map(bet =>
                                        bet.combination === combination
                                            ? { ...bet, resultOdds: value }
                                            : bet
                                    )
                                );
                            };

                            const handleUpdateResult = () => {
                                if (!editedRaceResult.first || !editedRaceResult.second || !editedRaceResult.third) {
                                    showToast('着順を全て入力してください', 'error');
                                    return;
                                }

                                const r1 = parseInt(editedRaceResult.first);
                                const r2 = parseInt(editedRaceResult.second);
                                const r3 = parseInt(editedRaceResult.third);

                                // 的中判定
                                const betList = editingResultData.originalData.betList;

                                const evaluatedBets = betList.map(bet => {
                                    let isWin = false;
                                    const ids = bet.ids.map(id => parseInt(id));

                                    switch (bet.type) {
                                        case 'tansho':
                                            isWin = ids[0] === r1;
                                            break;
                                        case 'fukusho':
                                            isWin = ids[0] === r1 || ids[0] === r2 || ids[0] === r3;
                                            break;
                                        case 'wide': {
                                            const winners = [r1, r2, r3];
                                            isWin = winners.includes(ids[0]) && winners.includes(ids[1]);
                                            break;
                                        }
                                        case 'umaren': {
                                            const umarenWinners = [r1, r2];
                                            isWin = umarenWinners.includes(ids[0]) && umarenWinners.includes(ids[1]);
                                            break;
                                        }
                                        case 'umatan':
                                            isWin = (ids[0] === r1 && ids[1] === r2);
                                            break;
                                        case 'sanrenpuku': {
                                            const sanrenWinners = [r1, r2, r3];
                                            isWin = sanrenWinners.includes(ids[0]) && sanrenWinners.includes(ids[1]) && sanrenWinners.includes(ids[2]);
                                            break;
                                        }
                                        case 'sanrentan':
                                            isWin = (ids[0] === r1 && ids[1] === r2 && ids[2] === r3);
                                            break;
                                    }

                                    const edited = editedBets.find(b => b.combination === bet.label) || {};
                                    const purchaseOdds = edited.purchaseOdds ?? (Number(editingResultData.originalData.oddsData[bet.key]) || 0);
                                    const resultOdds = edited.resultOdds ?? edited.odds ?? purchaseOdds;
                                    const stake = edited.stake ?? 0;

                                    return { ...edited, type: bet.type, combination: bet.label, purchaseOdds, resultOdds, stake, isWin };
                                });

                                const winCount = evaluatedBets.filter(r => r.isWin).length;
                                const totalInvested = editingResultData.totalInvested;
                                const totalReturn = evaluatedBets.reduce((sum, bet) => {
                                    if (!bet.isWin) return sum;
                                    return sum + Math.floor(bet.stake * (Number(bet.resultOdds) || 0));
                                }, 0);
                                const profit = totalReturn - totalInvested;

                                // 更新された結果オブジェクトを作成
                                const updatedResult = {
                                    ...editingResultData,
                                    result: { first: r1, second: r2, third: r3 },
                                    winCount,
                                    totalReturn,
                                    profit,
                                    reflectionNote, // 反省ノートを保存
                                    bets: evaluatedBets.map(bet => ({
                                        type: bet.type,
                                        combination: bet.combination,
                                        odds: bet.purchaseOdds,
                                        resultOdds: bet.resultOdds,
                                        stake: bet.stake,
                                        isWin: bet.isWin
                                    }))
                                };

                                updateResult(updatedResult);
                            };

                            const strategy = STRATEGIES[editingResultData.strategy] || STRATEGIES.data;
                            const confidence = CONFIDENCES[editingResultData.confidence] || CONFIDENCES.A;

                            return (
                                <main className="w-full px-3 sm:px-4 pt-4 pb-10 app-main">
                                    <div className="flex items-center gap-2 mb-4">
                                        <button onClick={() => { setEditingResultData(null); setCurrentView('results'); }} className="p-2 bg-white rounded-full shadow hover:bg-gray-100">
                                            <Icons.ArrowLeft size={20} className="text-gray-600" />
                                        </button>
                                        <h2 className="text-xl font-bold text-gray-700">結果を編集</h2>
                                    </div>

                                    <div className="w-full bg-white border border-slate-200 px-3 py-5 sm:px-4">
                                        <div className="mb-4">
                                            <div className="flex items-center gap-2 mb-2">
                                                <span className="font-bold text-xl text-gray-800">{editingResultData.place} {editingResultData.raceNum}R</span>
                                                <span className={`text-xs px-2 py-0.5 rounded border ${strategy.color.replace('focus:ring-', '')}`}>
                                                    {getReasonLabel(strategy.id)}
                                                </span>
                                                <span className={`text-xs px-2 py-0.5 rounded border ${confidence.color.replace('bg-', 'bg-opacity-10 bg-').replace('text-', 'text-opacity-90 text-')}`}>
                                                    {confidence.label}
                                                </span>
                                            </div>
                                            <span className="text-sm text-gray-600">{editingResultData.date}</span>
                                        </div>

                                        <div className="mb-4">
                                            <h3 className="font-bold text-gray-700 mb-2">着順を編集</h3>
                                            <div className="grid grid-cols-3 gap-3">
                                                <div>
                                                    <label className="text-xs text-gray-600 font-semibold block mb-1">1着</label>
                                                    <input
                                                        type="number"
                                                        min="1"
                                                        value={editedRaceResult.first}
                                                        onChange={(e) => setEditedRaceResult(prev => ({ ...prev, first: e.target.value }))}
                                                        className="w-full border border-gray-300 rounded px-3 py-2 text-center text-lg focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none"
                                                        inputMode="numeric"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="text-xs text-gray-600 font-semibold block mb-1">2着</label>
                                                    <input
                                                        type="number"
                                                        min="1"
                                                        value={editedRaceResult.second}
                                                        onChange={(e) => setEditedRaceResult(prev => ({ ...prev, second: e.target.value }))}
                                                        className="w-full border border-gray-300 rounded px-3 py-2 text-center text-lg focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none"
                                                        inputMode="numeric"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="text-xs text-gray-600 font-semibold block mb-1">3着</label>
                                                    <input
                                                        type="number"
                                                        min="1"
                                                        value={editedRaceResult.third}
                                                        onChange={(e) => setEditedRaceResult(prev => ({ ...prev, third: e.target.value }))}
                                                        className="w-full border border-gray-300 rounded px-3 py-2 text-center text-lg focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none"
                                                        inputMode="numeric"
                                                    />
                                                </div>
                                            </div>
                                        </div>

                                        <div className="mb-4">
                                            <h3 className="font-bold text-gray-700 mb-2">買い目一覧</h3>
                                            <div className="space-y-2 max-h-96 overflow-y-auto">
                                                {editingResultData.originalData.betList.map((bet, index) => {
                                                    const odds = editingResultData.originalData.oddsData[bet.key] || '-';
                                                    const edited = editedBets.find(b => b.combination === bet.label);
                                                    const stake = edited?.stake ?? (editingResultData.bets.find(b => b.combination === bet.label)?.stake || 0);
                                                    const resultOdds = edited?.resultOdds ?? '';
                                                    return (
                                                        <div key={index} className="p-2 bg-gray-50 rounded border">
                                                            <div className="flex items-start justify-between gap-3">
                                                                <div className="flex-1">
                                                                    <div className="flex items-center gap-2">
                                                                        <span className="font-semibold text-sm">{bet.label}</span>
                                                                        <span className="text-xs text-gray-500">({bet.type})</span>
                                                                    </div>
                                                                    <div className="text-xs text-gray-500 mt-1">購入時オッズ: <span className="font-bold text-gray-700">{odds}</span></div>
                                                                </div>
                                                                <div className="text-right text-xs text-gray-500">{stake.toLocaleString()}円</div>
                                                            </div>
                                                            <div className="mt-2">
                                                                <label className="text-xs text-gray-600 font-semibold block mb-1">的中時オッズ（確定）</label>
                                                                <input
                                                                    type="number"
                                                                    min="1"
                                                                    step="0.1"
                                                                    value={resultOdds === 0 ? '' : resultOdds}
                                                                    onChange={(e) => handleResultOddsChange(bet.label, e.target.value === '' ? '' : Number(e.target.value))}
                                                                    className="w-full border border-emerald-300 rounded px-3 py-2 text-right text-sm font-semibold focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500 bg-white"
                                                                    inputMode="decimal"
                                                                />
                                                            </div>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>

                                        <div className="mb-4">
                                            <h3 className="font-bold text-gray-700 mb-2 flex items-center gap-2">
                                                <Icons.FileText size={18} />
                                                反省ノート
                                            </h3>
                                            <textarea
                                                value={reflectionNote}
                                                onChange={(e) => setReflectionNote(e.target.value)}
                                                className="w-full border border-gray-300 rounded px-3 py-2 text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none resize-none"
                                                rows="5"
                                                placeholder="当たり外れの反省、気づいたこと、次回への改善点などをメモ..."
                                            />
                                        </div>

                                        <button
                                            onClick={handleUpdateResult}
                                            className="w-full bg-blue-600 text-white font-bold py-3 rounded-lg hover:bg-blue-700 flex items-center justify-center gap-2"
                                        >
                                            <Icons.CheckCircle size={20} />
                                            結果を更新
                                        </button>
                                    </div>
                                </main>
                            );
                        };

                        return <EditResultView />;
                    })()}

                    {currentView === 'courseData' && (
                        <main className="w-full px-3 sm:px-4 pt-4 pb-10 app-main">
                            <div className="flex items-center gap-2 mb-4"><button onClick={() => setCurrentView('calculator')} className="p-2 bg-white rounded-full shadow hover:bg-gray-100"><Icons.ArrowLeft size={20} className="text-gray-600" /></button><h2 className="text-xl font-bold text-gray-700">コースデータ</h2></div>

                            {Object.keys(courseData).length === 0 ? (
                                <div className="text-center py-12 text-gray-400">
                                    <p>データが読み込まれていません</p>
                                </div>
                            ) : (
                                <div className="space-y-4">
                                    {Object.entries(courseData).map(([place, courses]) => (
                                        <PlaceAccordion key={place} place={place} courses={courses} />
                                    ))}
                                </div>
                            )}
                        </main>
                    )}
                </div>
            );
        };

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<HorseRacingOddsManager />);
    </script>
</body>
</html>
