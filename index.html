<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ODDS MASTER</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        .animate-slide-in {
            animation: slideIn 0.3s ease-out;
        }
        
        /* Modern Calendar Styling */
        input[type="date"] {
            position: relative;
            background: white;
            cursor: pointer;
        }
        
        input[type="date"]::-webkit-calendar-picker-indicator {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: auto;
            height: auto;
            color: transparent;
            background: transparent;
            cursor: pointer;
        }
        
        input[type="date"]:hover {
            border-color: #10b981;
        }
        
        input[type="date"]:focus {
            outline: none;
            border-color: #10b981;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useEffect } = React;
        const { createElement: iconCreate } = React;
        
        // Lucide icon wrapper
        const Icon = ({ name, ...props }) => {
            useEffect(() => {
                if (window.lucide) {
                    window.lucide.createIcons();
                }
            }, []);
            return iconCreate('i', { 'data-lucide': name, ...props });
        };
        
        const Settings = (props) => <Icon name="settings" {...props} />;
        const Calculator = (props) => <Icon name="calculator" {...props} />;
        const Trash2 = (props) => <Icon name="trash-2" {...props} />;
        const Save = (props) => <Icon name="save" {...props} />;
        const Info = (props) => <Icon name="info" {...props} />;
        const RefreshCw = (props) => <Icon name="refresh-cw" {...props} />;
        const Layers = (props) => <Icon name="layers" {...props} />;
        const GitMerge = (props) => <Icon name="git-merge" {...props} />;
        const PlusCircle = (props) => <Icon name="plus-circle" {...props} />;
        const X = (props) => <Icon name="x" {...props} />;
        const CheckSquare = (props) => <Icon name="check-square" {...props} />;
        const Calendar = (props) => <Icon name="calendar" {...props} />;
        const MapPin = (props) => <Icon name="map-pin" {...props} />;
        const Flag = (props) => <Icon name="flag" {...props} />;
        const FileText = (props) => <Icon name="file-text" {...props} />;
        const History = (props) => <Icon name="history" {...props} />;
        const ArrowLeft = (props) => <Icon name="arrow-left" {...props} />;

        const HorseRacingOddsManager = () => {
            // State Definitions
            const [currentView, setCurrentView] = useState('calculator');
            const [raceMeta, setRaceMeta] = useState({
                date: new Date().toISOString().split('T')[0],
                place: '東京',
                raceNum: 11,
                note: ''
            });

            const [horseCount, setHorseCount] = useState(18); 
            const [betType, setBetType] = useState('tansho');
            const [votingMode, setVotingMode] = useState('box'); 
            
            const [axisHorse, setAxisHorse] = useState(null); 
            const [opponentHorses, setOpponentHorses] = useState([]); 
            const [formation, setFormation] = useState({ first: [], second: [], third: [] });
            const [boxHorses, setBoxHorses] = useState([]);

            const [betList, setBetList] = useState([]); 
            const [oddsData, setOddsData] = useState({}); 
            const [totalBudget, setTotalBudget] = useState(10000); 
            const [allocationMode, setAllocationMode] = useState('profit'); 

            const [savedHistory, setSavedHistory] = useState([]);
            
            // Toast notification state
            const [toast, setToast] = useState(null);
            
            // Confirmation modal state
            const [confirmModal, setConfirmModal] = useState(null);
            
            // Calendar picker state
            const [showCalendar, setShowCalendar] = useState(false);
            const [calendarDate, setCalendarDate] = useState(new Date());
            
            // Show toast helper
            const showToast = (message, type = 'success') => {
                setToast({ message, type });
                setTimeout(() => setToast(null), 3000);
            };
            
            // Show confirmation modal
            const showConfirm = (message, onConfirm) => {
                setConfirmModal({ message, onConfirm });
            };
            
            // Handle confirm
            const handleConfirm = () => {
                if (confirmModal?.onConfirm) {
                    confirmModal.onConfirm();
                }
                setConfirmModal(null);
            };
            
            // Calendar helpers
            const getDaysInMonth = (date) => {
                const year = date.getFullYear();
                const month = date.getMonth();
                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const daysInMonth = lastDay.getDate();
                const startingDayOfWeek = firstDay.getDay();
                
                return { daysInMonth, startingDayOfWeek, year, month };
            };
            
            const selectDate = (day) => {
                const year = calendarDate.getFullYear();
                const month = calendarDate.getMonth();
                const selectedDate = new Date(year, month, day);
                const dateString = selectedDate.toISOString().split('T')[0];
                handleMetaChange('date', dateString);
                setShowCalendar(false);
            };
            
            const changeMonth = (delta) => {
                setCalendarDate(prev => {
                    const newDate = new Date(prev);
                    newDate.setMonth(newDate.getMonth() + delta);
                    return newDate;
                });
            };

            // Load history from localStorage on mount
            useEffect(() => {
                const saved = localStorage.getItem('jra_odds_history');
                if (saved) {
                    try {
                        setSavedHistory(JSON.parse(saved));
                    } catch (e) {
                        console.error("Failed to load history", e);
                    }
                }
            }, []);
            
            // Update calendar date when raceMeta.date changes
            useEffect(() => {
                if (raceMeta.date) {
                    setCalendarDate(new Date(raceMeta.date));
                }
            }, [raceMeta.date]);

            // Race Meta Change Logic
            const handleMetaChange = (field, value) => {
                if (betList.length > 0) {
                    showConfirm('レース情報を変更すると、現在の買い目リストとオッズはリセットされます。', () => {
                        setRaceMeta(prev => ({ ...prev, [field]: value }));
                        setBetList([]);
                        setOddsData({});
                    });
                } else {
                    setRaceMeta(prev => ({ ...prev, [field]: value }));
                }
            };

            // Nagashi Logic
            const handleNagashiClick = (number) => {
                if (axisHorse === number) {
                    setAxisHorse(null);
                } else if (opponentHorses.includes(number)) {
                    setOpponentHorses(prev => prev.filter(h => h !== number));
                } else {
                    if (axisHorse === null) {
                        setAxisHorse(number);
                    } else {
                        setOpponentHorses(prev => [...prev, number].sort((a, b) => a - b));
                    }
                }
            };

            // Formation Logic
            const toggleFormationHorse = (rowKey, number) => {
                setFormation(prev => {
                    const currentList = prev[rowKey];
                    if (currentList.includes(number)) {
                        return { ...prev, [rowKey]: currentList.filter(n => n !== number) };
                    } else {
                        return { ...prev, [rowKey]: [...currentList, number].sort((a, b) => a - b) };
                    }
                });
            };

            // Box / Normal Logic
            const toggleBoxHorse = (number) => {
                setBoxHorses(prev => {
                    if (prev.includes(number)) {
                        return prev.filter(n => n !== number);
                    } else {
                        return [...prev, number].sort((a, b) => a - b);
                    }
                });
            };

            // Clear Inputs (Selection only)
            const clearSelection = () => {
                setAxisHorse(null);
                setOpponentHorses([]);
                setFormation({ first: [], second: [], third: [] });
                setBoxHorses([]);
            };

            // Clear All (Including List)
            const clearAll = () => {
                showConfirm('現在の入力内容をすべて消去しますか？', () => {
                    clearSelection();
                    setBetList([]);
                    setOddsData({});
                    setRaceMeta({
                        date: new Date().toISOString().split('T')[0],
                        place: '東京',
                        raceNum: 11,
                        note: ''
                    });
                });
            };

            // Switch bet type handler
            const handleBetTypeChange = (type) => {
                setBetType(type);
                if (type === 'tansho' || type === 'fukusho') {
                    setVotingMode('box');
                } else {
                    setVotingMode('nagashi');
                }
            };

            // History Logic
            const saveToHistory = () => {
                if (betList.length === 0) {
                    showToast('保存する買い目がありません', 'error');
                    return;
                }

                const newEntry = {
                    id: Date.now(),
                    meta: { ...raceMeta },
                    data: {
                        betList: [...betList],
                        oddsData: { ...oddsData },
                        totalBudget,
                        allocationMode
                    },
                    savedAt: new Date().toISOString()
                };

                const newHistory = [newEntry, ...savedHistory];
                setSavedHistory(newHistory);
                localStorage.setItem('jra_odds_history', JSON.stringify(newHistory));
                
                showToast(`${raceMeta.place} ${raceMeta.raceNum}R を保存しました (${betList.length}点)`, 'success');
            };

            const loadFromHistory = (entry) => {
                showConfirm('現在の編集内容を破棄して、保存データを読み込みますか？', () => {
                    clearSelection();
                    setRaceMeta({ ...entry.meta });
                    setBetList([...entry.data.betList]);
                    setOddsData({ ...entry.data.oddsData });
                    setTotalBudget(entry.data.totalBudget || 10000);
                    setAllocationMode(entry.data.allocationMode || 'profit');
                    
                    setCurrentView('calculator');

                    setTimeout(() => {
                        showToast(`${entry.meta.place} ${entry.meta.raceNum}R を読み込みました (${entry.data.betList.length}点)`, 'success');
                    }, 100);

                    setTimeout(() => {
                        const listSection = document.getElementById('bet-list-section');
                        if (listSection) {
                            listSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    }, 300);
                });
            };

            const deleteHistoryItem = (id) => {
                showConfirm('この履歴を削除しますか？', () => {
                    const newHistory = savedHistory.filter(item => item.id !== id);
                    setSavedHistory(newHistory);
                    localStorage.setItem('jra_odds_history', JSON.stringify(newHistory));
                    showToast('履歴を削除しました', 'success');
                });
            };

            // Combination Generator
            const previewCombinations = useMemo(() => {
                let combos = [];
                const sortNums = (arr) => arr.sort((a, b) => a - b);

                if (votingMode === 'box') {
                    if (boxHorses.length === 0) return [];
                    const horses = [...boxHorses];

                    if (betType === 'tansho' || betType === 'fukusho') {
                        horses.forEach(h => {
                            combos.push({ ids: [h], key: `${betType}:${h}`, label: `${h}番`, type: betType });
                        });
                    } else if (betType === 'umaren' || betType === 'wide') {
                        for (let i = 0; i < horses.length; i++) {
                            for (let j = i + 1; j < horses.length; j++) {
                                const sorted = sortNums([horses[i], horses[j]]);
                                combos.push({ ids: sorted, key: `${betType}:${sorted.join('-')}`, label: sorted.join('-'), type: betType });
                            }
                        }
                    } else if (betType === 'umatan') {
                        for (let i = 0; i < horses.length; i++) {
                            for (let j = 0; j < horses.length; j++) {
                                if (i === j) continue;
                                const combo = [horses[i], horses[j]];
                                combos.push({ ids: combo, key: `${betType}:${combo.join('>')}`, label: combo.join('>'), type: betType });
                            }
                        }
                    } else if (betType === 'sanrenpuku') {
                        for (let i = 0; i < horses.length; i++) {
                            for (let j = i + 1; j < horses.length; j++) {
                                for (let k = j + 1; k < horses.length; k++) {
                                    const sorted = sortNums([horses[i], horses[j], horses[k]]);
                                    combos.push({ ids: sorted, key: `${betType}:${sorted.join('-')}`, label: sorted.join('-'), type: betType });
                                }
                            }
                        }
                    } else if (betType === 'sanrentan') {
                        for (let i = 0; i < horses.length; i++) {
                            for (let j = 0; j < horses.length; j++) {
                                for (let k = 0; k < horses.length; k++) {
                                    if (i === j || j === k || i === k) continue;
                                    const combo = [horses[i], horses[j], horses[k]];
                                    combos.push({ ids: combo, key: `${betType}:${combo.join('>')}`, label: combo.join('>'), type: betType });
                                }
                            }
                        }
                    }
                } else if (votingMode === 'nagashi') {
                    if (!axisHorse || opponentHorses.length === 0) return [];
                    const opps = [...opponentHorses];

                    if (betType === 'umaren' || betType === 'wide') {
                        opps.forEach(opp => {
                            const combo = sortNums([axisHorse, opp]);
                            combos.push({ ids: combo, key: `${betType}:${combo.join('-')}`, label: combo.join('-'), type: betType });
                        });
                    } else if (betType === 'umatan') {
                        opps.forEach(opp => {
                            const combo = [axisHorse, opp];
                            combos.push({ ids: combo, key: `${betType}:${combo.join('>')}`, label: combo.join('>'), type: betType });
                        });
                    } else if (betType === 'sanrenpuku') {
                        if (opps.length < 2) return [];
                        for (let i = 0; i < opps.length; i++) {
                            for (let j = i + 1; j < opps.length; j++) {
                                const raw = [axisHorse, opps[i], opps[j]];
                                const sorted = sortNums(raw);
                                combos.push({ ids: sorted, key: `${betType}:${sorted.join('-')}`, label: sorted.join('-'), type: betType });
                            }
                        }
                    } else if (betType === 'sanrentan') {
                        if (opps.length < 2) return [];
                        for (let i = 0; i < opps.length; i++) {
                            for (let j = 0; j < opps.length; j++) {
                                if (i === j) continue;
                                const combo = [axisHorse, opps[i], opps[j]];
                                combos.push({ ids: combo, key: `${betType}:${combo.join('>')}`, label: combo.join('>'), type: betType });
                            }
                        }
                    }
                } else if (votingMode === 'formation') {
                    const { first, second, third } = formation;
                    const isUnique = (arr) => new Set(arr).size === arr.length;

                    if (betType === 'umaren' || betType === 'wide') {
                        if (first.length === 0 || second.length === 0) return [];
                        const seen = new Set();
                        first.forEach(f => {
                            second.forEach(s => {
                                if (f === s) return;
                                const sorted = sortNums([f, s]);
                                const uniqueKey = sorted.join('-');
                                if (!seen.has(uniqueKey)) {
                                    seen.add(uniqueKey);
                                    combos.push({ ids: sorted, key: `${betType}:${uniqueKey}`, label: uniqueKey, type: betType });
                                }
                            });
                        });
                    } else if (betType === 'umatan') {
                        if (first.length === 0 || second.length === 0) return [];
                        first.forEach(f => {
                            second.forEach(s => {
                                if (f === s) return;
                                const label = `${f}>${s}`;
                                combos.push({ ids: [f, s], key: `${betType}:${label}`, label, type: betType });
                            });
                        });
                    } else if (betType === 'sanrenpuku') {
                        if (first.length === 0 || second.length === 0 || third.length === 0) return [];
                        const seen = new Set();
                        first.forEach(f => {
                            second.forEach(s => {
                                third.forEach(t => {
                                    if (!isUnique([f, s, t])) return;
                                    const sorted = sortNums([f, s, t]);
                                    const uniqueKey = sorted.join('-');
                                    if (!seen.has(uniqueKey)) {
                                        seen.add(uniqueKey);
                                        combos.push({ ids: sorted, key: `${betType}:${uniqueKey}`, label: uniqueKey, type: betType });
                                    }
                                });
                            });
                        });
                    } else if (betType === 'sanrentan') {
                        if (first.length === 0 || second.length === 0 || third.length === 0) return [];
                        first.forEach(f => {
                            second.forEach(s => {
                                third.forEach(t => {
                                    if (!isUnique([f, s, t])) return;
                                    const label = `${f}>${s}>${t}`;
                                    combos.push({ ids: [f, s, t], key: `${betType}:${label}`, label, type: betType });
                                });
                            });
                        });
                    }
                }

                return combos;
            }, [axisHorse, opponentHorses, formation, boxHorses, betType, votingMode]);

            const addBetsToList = () => {
                if (previewCombinations.length === 0) return;
                setBetList(prev => {
                    const existingKeys = new Set(prev.map(b => b.key));
                    const newBets = previewCombinations.filter(b => !existingKeys.has(b.key));
                    return [...prev, ...newBets];
                });
            };

            const removeBet = (key) => {
                setBetList(prev => prev.filter(b => b.key !== key));
            };

            const handleOddsChange = (key, value, oddsType = 'default') => {
                if (oddsType === 'default') {
                    setOddsData(prev => ({ ...prev, [key]: parseFloat(value) }));
                } else {
                    // For wide bets with multiple odds (min, mid, max)
                    setOddsData(prev => ({
                        ...prev,
                        [key]: {
                            ...(typeof prev[key] === 'object' ? prev[key] : {}),
                            [oddsType]: parseFloat(value)
                        }
                    }));
                }
            };

            const fillMockOdds = () => {
                const newOdds = { ...oddsData };
                betList.forEach(c => {
                    if (!newOdds[c.key]) {
                        if (c.type === 'wide') {
                            // Wide bets get 2 different odds (min and max)
                            const baseOdds = Math.random() * 50 + 10;
                            newOdds[c.key] = {
                                min: parseFloat((baseOdds * 0.8).toFixed(1)),
                                max: parseFloat((baseOdds * 1.3).toFixed(1))
                            };
                        } else {
                            const randomOdds = (Math.random() * 100 + 5).toFixed(1);
                            newOdds[c.key] = parseFloat(randomOdds);
                        }
                    }
                });
                setOddsData(newOdds);
            };

            const calculatedData = useMemo(() => {
                if (betList.length === 0) return [];
                
                const results = betList.map(c => ({ ...c, odds: oddsData[c.key] || 0 }));
                const validBets = results.filter(r => {
                    if (r.type === 'wide') {
                        const wideOdds = oddsData[r.key];
                        return wideOdds && typeof wideOdds === 'object' && (wideOdds.min > 0 || wideOdds.max > 0);
                    }
                    return r.odds > 0;
                });
                
                if (validBets.length === 0) {
                    return results.map(r => ({ ...r, stake: 0, return: 0, profit: -totalBudget }));
                }

                if (allocationMode === 'flat') {
                    const stakePerBet = Math.floor((totalBudget / results.length) / 100) * 100;
                    return results.map(r => ({
                        ...r,
                        stake: stakePerBet,
                        return: Math.floor(stakePerBet * r.odds),
                        profit: Math.floor(stakePerBet * r.odds) - (stakePerBet * results.length)
                    }));
                } else {
                    // For profit mode, use average odds for wide bets
                    const sumInverseOdds = validBets.reduce((acc, curr) => {
                        if (curr.type === 'wide') {
                            const wideOdds = oddsData[curr.key];
                            const avgOdds = ((wideOdds.min || 0) + (wideOdds.max || 0)) / 2;
                            return acc + (avgOdds > 0 ? 1 / avgOdds : 0);
                        }
                        return acc + (1 / curr.odds);
                    }, 0);
                    
                    const calculatedBets = results.map(r => {
                        if (r.type === 'wide') {
                            const wideOdds = oddsData[r.key];
                            if (!wideOdds || typeof wideOdds !== 'object') {
                                return { ...r, stake: 0, return: 0, profit: 0 };
                            }
                            const avgOdds = ((wideOdds.min || 0) + (wideOdds.max || 0)) / 2;
                            if (avgOdds <= 0) return { ...r, stake: 0, return: 0, profit: 0 };
                            let rawStake = (totalBudget / sumInverseOdds) / avgOdds;
                            let stake = Math.round(rawStake / 100) * 100;
                            if (stake < 100) stake = 100;
                            return { ...r, stake };
                        } else {
                            if (r.odds <= 0) return { ...r, stake: 0, return: 0, profit: 0 };
                            let rawStake = (totalBudget / sumInverseOdds) / r.odds;
                            let stake = Math.round(rawStake / 100) * 100;
                            if (stake < 100) stake = 100;
                            return { ...r, stake };
                        }
                    });

                    let currentTotal = calculatedBets.reduce((sum, item) => sum + item.stake, 0);
                    return calculatedBets.map(r => ({
                        ...r,
                        return: Math.floor(r.stake * r.odds),
                        profit: Math.floor(r.stake * r.odds) - currentTotal
                    }));
                }
            }, [betList, oddsData, totalBudget, allocationMode]);

            const stats = useMemo(() => {
                const totalStake = calculatedData.reduce((acc, curr) => acc + curr.stake, 0);
                const validCombos = calculatedData.filter(c => {
                    if (c.type === 'wide') {
                        const wideOdds = oddsData[c.key];
                        return wideOdds && typeof wideOdds === 'object' && (wideOdds.min > 0 || wideOdds.max > 0);
                    }
                    return c.odds > 0;
                });
                const sumInv = validCombos.reduce((acc, curr) => {
                    if (curr.type === 'wide') {
                        const wideOdds = oddsData[curr.key];
                        const avgOdds = ((wideOdds.min || 0) + (wideOdds.max || 0)) / 2;
                        return acc + (avgOdds > 0 ? 1 / avgOdds : 0);
                    }
                    return acc + (1 / curr.odds);
                }, 0);
                const syntheticOdds = sumInv > 0 ? (1 / sumInv).toFixed(2) : '---';
                return { totalStake, syntheticOdds, count: betList.length };
            }, [calculatedData, betList, oddsData]);

            // Render Components
            const renderHorseButton = (num, isSelected, colorClass, onClick) => (
                React.createElement('button', {
                    key: num,
                    onClick: onClick,
                    className: `h-9 w-full rounded border text-sm font-bold transition-all active:scale-95 ${
                        isSelected 
                            ? `${colorClass} text-white shadow-md ring-1 ring-opacity-50` 
                            : "bg-white border-gray-300 text-gray-600 hover:bg-gray-50"
                    }`
                }, num)
            );

            const getRowLabel = (index, type) => {
                if (type === 'sanrenpuku' || type === 'umaren' || type === 'wide') return `${index}頭目`;
                return `${index}着`;
            };

            const getTypeName = (type) => {
                const types = {
                    sanrenpuku: '三連複', sanrentan: '三連単', umaren: '馬連', umatan: '馬単',
                    wide: 'ワイド', tansho: '単勝', fukusho: '複勝'
                };
                return types[type] || type;
            };

            const isSingleHorseBet = betType === 'tansho' || betType === 'fukusho';

            const formatDate = (dateStr) => {
                const d = new Date(dateStr);
                return `${d.getMonth() + 1}/${d.getDate()}`;
            };

            // MAIN RENDER
            return (
                <div className="min-h-screen bg-gray-100 font-sans pb-20">
                    {/* Confirmation Modal */}
                    {confirmModal && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4">
                            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full p-6 transform transition-all animate-slide-in">
                                <div className="flex items-center gap-3 mb-4">
                                    <div className="w-12 h-12 bg-yellow-100 rounded-full flex items-center justify-center">
                                        <Info size={24} className="text-yellow-600" />
                                    </div>
                                    <h3 className="text-lg font-bold text-gray-800">確認</h3>
                                </div>
                                <p className="text-gray-600 mb-6 leading-relaxed">{confirmModal.message}</p>
                                <div className="flex gap-3">
                                    <button
                                        onClick={() => setConfirmModal(null)}
                                        className="flex-1 px-4 py-3 bg-gray-200 text-gray-700 rounded-lg font-bold hover:bg-gray-300 transition-colors"
                                    >
                                        キャンセル
                                    </button>
                                    <button
                                        onClick={handleConfirm}
                                        className="flex-1 px-4 py-3 bg-emerald-600 text-white rounded-lg font-bold hover:bg-emerald-700 transition-colors"
                                    >
                                        OK
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* Toast Notification */}
                    {toast && (
                        <div className={`fixed top-20 right-4 z-50 px-6 py-4 rounded-lg shadow-2xl transform transition-all duration-300 ${
                            toast.type === 'success' ? 'bg-emerald-600' : 'bg-red-500'
                        } text-white font-bold flex items-center gap-3 animate-slide-in`}>
                            {toast.type === 'success' ? (
                                <CheckSquare size={24} />
                            ) : (
                                <X size={24} />
                            )}
                            <span>{toast.message}</span>
                        </div>
                    )}
                    
                    {/* Header */}
                    <header className="bg-emerald-700 text-white p-4 sticky top-0 z-30 shadow-md">
                        <div className="max-w-3xl mx-auto flex justify-between items-center">
                            <h1 className="text-xl font-bold flex items-center gap-2">
                                <Calculator size={20} />
                                ODDS MASTER
                            </h1>
                            <div className="flex gap-2">
                                <button 
                                    onClick={() => setCurrentView('history')}
                                    className={`text-xs px-3 py-1 rounded flex items-center gap-1 border border-emerald-600 ${currentView === 'history' ? 'bg-emerald-900' : 'bg-emerald-800 hover:bg-emerald-600'}`}
                                >
                                    <History size={14} /> 履歴
                                </button>
                                {currentView === 'calculator' && (
                                    <button onClick={clearAll} className="text-xs bg-emerald-800 px-3 py-1 rounded hover:bg-emerald-600 border border-emerald-600">
                                        リセット
                                    </button>
                                )}
                            </div>
                        </div>
                    </header>

                    {/* CALCULATOR VIEW */}
                    {currentView === 'calculator' && (
                        <main className="max-w-3xl mx-auto p-4 space-y-6">
                            {/* Race Metadata Input */}
                            <section className="bg-white rounded-lg shadow p-3">
                                <div className="grid grid-cols-2 sm:grid-cols-4 gap-3">
                                    <div className="col-span-2 sm:col-span-1 relative">
                                        <label className="flex items-center gap-1 text-xs text-gray-500 font-bold mb-1">
                                            <Calendar size={12} /> 日付
                                        </label>
                                        <button
                                            type="button"
                                            onClick={() => setShowCalendar(!showCalendar)}
                                            className="w-full text-sm bg-white border-2 border-gray-200 rounded-lg px-3 py-2 focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500 transition-all hover:border-emerald-300 text-left flex items-center justify-between"
                                        >
                                            <span>{raceMeta.date}</span>
                                            <Calendar size={16} className="text-gray-400" />
                                        </button>
                                        
                                        {showCalendar && (
                                            <>
                                                <div 
                                                    className="fixed inset-0 z-40" 
                                                    onClick={() => setShowCalendar(false)}
                                                ></div>
                                                <div className="absolute top-full left-0 mt-2 bg-white rounded-2xl shadow-2xl border border-gray-200 p-4 z-50 w-80">
                                                    <div className="flex items-center justify-between mb-4">
                                                        <button
                                                            type="button"
                                                            onClick={() => changeMonth(-1)}
                                                            className="p-2 hover:bg-gray-100 rounded-lg transition-colors"
                                                        >
                                                            <ArrowLeft size={20} />
                                                        </button>
                                                        <div className="font-bold text-gray-800">
                                                            {calendarDate.getFullYear()}年 {calendarDate.getMonth() + 1}月
                                                        </div>
                                                        <button
                                                            type="button"
                                                            onClick={() => changeMonth(1)}
                                                            className="p-2 hover:bg-gray-100 rounded-lg transition-colors transform rotate-180"
                                                        >
                                                            <ArrowLeft size={20} />
                                                        </button>
                                                    </div>
                                                    
                                                    <div className="grid grid-cols-7 gap-1 mb-2">
                                                        {['日', '月', '火', '水', '木', '金', '土'].map(day => (
                                                            <div key={day} className="text-center text-xs font-bold text-gray-500 py-2">
                                                                {day}
                                                            </div>
                                                        ))}
                                                    </div>
                                                    
                                                    <div className="grid grid-cols-7 gap-1">
                                                        {(() => {
                                                            const { daysInMonth, startingDayOfWeek } = getDaysInMonth(calendarDate);
                                                            const days = [];
                                                            
                                                            // Empty cells before first day
                                                            for (let i = 0; i < startingDayOfWeek; i++) {
                                                                days.push(<div key={`empty-${i}`} className="aspect-square"></div>);
                                                            }
                                                            
                                                            // Days of month
                                                            const selectedDate = new Date(raceMeta.date);
                                                            for (let day = 1; day <= daysInMonth; day++) {
                                                                const isSelected = 
                                                                    selectedDate.getFullYear() === calendarDate.getFullYear() &&
                                                                    selectedDate.getMonth() === calendarDate.getMonth() &&
                                                                    selectedDate.getDate() === day;
                                                                
                                                                const isToday = 
                                                                    new Date().getFullYear() === calendarDate.getFullYear() &&
                                                                    new Date().getMonth() === calendarDate.getMonth() &&
                                                                    new Date().getDate() === day;
                                                                
                                                                days.push(
                                                                    <button
                                                                        key={day}
                                                                        type="button"
                                                                        onClick={() => selectDate(day)}
                                                                        className={`aspect-square rounded-lg text-sm font-medium transition-all hover:bg-emerald-100 ${
                                                                            isSelected 
                                                                                ? 'bg-emerald-600 text-white hover:bg-emerald-700' 
                                                                                : isToday
                                                                                ? 'border-2 border-emerald-600 text-emerald-600'
                                                                                : 'text-gray-700'
                                                                        }`}
                                                                    >
                                                                        {day}
                                                                    </button>
                                                                );
                                                            }
                                                            
                                                            return days;
                                                        })()}
                                                    </div>
                                                </div>
                                            </>
                                        )}
                                    </div>
                                    <div>
                                        <label className="flex items-center gap-1 text-xs text-gray-500 font-bold mb-1">
                                            <MapPin size={12} /> 場所
                                        </label>
                                        <select 
                                            value={raceMeta.place}
                                            onChange={(e) => handleMetaChange('place', e.target.value)}
                                            className="w-full text-sm border-gray-300 rounded border p-1.5"
                                        >
                                            {['札幌','函館','福島','新潟','東京','中山','中京','京都','阪神','小倉'].map(p => (
                                                <option key={p} value={p}>{p}</option>
                                            ))}
                                        </select>
                                    </div>
                                    <div>
                                        <label className="flex items-center gap-1 text-xs text-gray-500 font-bold mb-1">
                                            <Flag size={12} /> R
                                        </label>
                                        <select 
                                            value={raceMeta.raceNum}
                                            onChange={(e) => handleMetaChange('raceNum', parseInt(e.target.value))}
                                            className="w-full text-sm border-gray-300 rounded border p-1.5"
                                        >
                                            {Array.from({length:12}, (_, i) => i + 1).map(n => (
                                                <option key={n} value={n}>{n}R</option>
                                            ))}
                                        </select>
                                    </div>
                                    <div className="col-span-2 sm:col-span-1">
                                        <label className="flex items-center gap-1 text-xs text-gray-500 font-bold mb-1">
                                            <FileText size={12} /> メモ
                                        </label>
                                        <input 
                                            type="text" 
                                            placeholder="レース名など"
                                            value={raceMeta.note}
                                            onChange={(e) => setRaceMeta(prev => ({ ...prev, note: e.target.value }))}
                                            className="w-full text-sm border-gray-300 rounded border p-1.5"
                                        />
                                    </div>
                                </div>
                            </section>

                            {/* Selection Area */}
                            <section className="bg-white rounded-lg shadow overflow-hidden relative">
                                <div className="p-3 bg-gray-50 border-b flex justify-between items-center">
                                    <h2 className="font-bold text-gray-700 flex items-center gap-2">
                                        <Settings size={18}/> 買い目作成
                                    </h2>
                                    <button onClick={clearSelection} className="text-xs text-gray-500 hover:text-red-500 underline">
                                        選択クリア
                                    </button>
                                </div>
                                
                                {/* Controls */}
                                <div className="p-4 space-y-3 border-b border-gray-100">
                                    <div className="flex flex-col sm:flex-row gap-3">
                                        <div className="flex-1">
                                            <label className="block text-xs font-bold text-gray-500 mb-1">式別</label>
                                            <select 
                                                className="w-full bg-white border border-gray-300 text-gray-700 text-sm rounded p-2 focus:ring-emerald-500"
                                                value={betType}
                                                onChange={(e) => handleBetTypeChange(e.target.value)}
                                            >
                                                <option value="tansho">単勝</option>
                                                <option value="fukusho">複勝</option>
                                                <option value="wide">ワイド</option>
                                                <option value="umaren">馬連</option>
                                                <option value="umatan">馬単</option>
                                                <option value="sanrenpuku">三連複</option>
                                                <option value="sanrentan">三連単</option>
                                            </select>
                                        </div>

                                        <div className="flex-1">
                                            <label className="block text-xs font-bold text-gray-500 mb-1">方式</label>
                                            <div className="flex bg-gray-200 rounded p-1">
                                                {!isSingleHorseBet && (
                                                    <>
                                                        <button 
                                                            onClick={() => setVotingMode('nagashi')}
                                                            className={`flex-1 flex items-center justify-center gap-1 text-xs py-1.5 rounded transition-all ${
                                                                votingMode === 'nagashi' ? 'bg-white text-emerald-700 shadow font-bold' : 'text-gray-500'
                                                            }`}
                                                        >
                                                            <GitMerge size={14} className="rotate-90" /> 流し
                                                        </button>
                                                        <button 
                                                            onClick={() => setVotingMode('formation')}
                                                            className={`flex-1 flex items-center justify-center gap-1 text-xs py-1.5 rounded transition-all ${
                                                                votingMode === 'formation' ? 'bg-white text-emerald-700 shadow font-bold' : 'text-gray-500'
                                                            }`}
                                                        >
                                                            <Layers size={14} /> フォーメ
                                                        </button>
                                                    </>
                                                )}
                                                <button 
                                                    onClick={() => setVotingMode('box')}
                                                    className={`flex-1 flex items-center justify-center gap-1 text-xs py-1.5 rounded transition-all ${
                                                        votingMode === 'box' ? 'bg-white text-emerald-700 shadow font-bold' : 'text-gray-500'
                                                    }`}
                                                >
                                                    <CheckSquare size={14} /> {isSingleHorseBet ? '通常' : 'BOX'}
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                {/* Horse Grid */}
                                <div className="p-4">
                                    {votingMode === 'box' && (
                                        <>
                                            <div className="mb-2 text-xs text-center text-gray-500">
                                                {isSingleHorseBet ? '馬を選択してください（複数選択可）' : 'ボックス買いする馬を選択してください'}
                                            </div>
                                            <div className="grid grid-cols-6 sm:grid-cols-9 gap-1.5">
                                                {Array.from({ length: horseCount }, (_, i) => i + 1).map(num => {
                                                    const isSelected = boxHorses.includes(num);
                                                    return renderHorseButton(num, isSelected, 'bg-emerald-600 border-emerald-700', () => toggleBoxHorse(num));
                                                })}
                                            </div>
                                        </>
                                    )}

                                    {votingMode === 'nagashi' && !isSingleHorseBet && (
                                        <>
                                            <div className="mb-2 text-xs text-center text-gray-500">
                                                軸(ピンク)1頭 → 相手(青)を選択
                                            </div>
                                            <div className="grid grid-cols-6 sm:grid-cols-9 gap-1.5">
                                                {Array.from({ length: horseCount }, (_, i) => i + 1).map(num => {
                                                    const isAxis = axisHorse === num;
                                                    const isOpp = opponentHorses.includes(num);
                                                    const color = isAxis ? 'bg-pink-500 border-pink-600' : 'bg-blue-500 border-blue-600';
                                                    return renderHorseButton(num, isAxis || isOpp, color, () => handleNagashiClick(num));
                                                })}
                                            </div>
                                        </>
                                    )}

                                    {votingMode === 'formation' && !isSingleHorseBet && (
                                        <div className="space-y-4">
                                            <div>
                                                <div className="flex items-center gap-2 mb-1">
                                                    <span className="bg-pink-100 text-pink-800 text-xs font-bold px-2 py-0.5 rounded border border-pink-200">
                                                        {getRowLabel(1, betType)}
                                                    </span>
                                                </div>
                                                <div className="grid grid-cols-9 gap-1">
                                                    {Array.from({ length: horseCount }, (_, i) => i + 1).map(num => 
                                                        renderHorseButton(num, formation.first.includes(num), 'bg-pink-500 border-pink-600', () => toggleFormationHorse('first', num))
                                                    )}
                                                </div>
                                            </div>
                                            <div>
                                                <div className="flex items-center gap-2 mb-1">
                                                    <span className="bg-blue-100 text-blue-800 text-xs font-bold px-2 py-0.5 rounded border border-blue-200">
                                                        {getRowLabel(2, betType)}
                                                    </span>
                                                </div>
                                                <div className="grid grid-cols-9 gap-1">
                                                    {Array.from({ length: horseCount }, (_, i) => i + 1).map(num => 
                                                        renderHorseButton(num, formation.second.includes(num), 'bg-blue-500 border-blue-600', () => toggleFormationHorse('second', num))
                                                    )}
                                                </div>
                                            </div>
                                            {(betType === 'sanrenpuku' || betType === 'sanrentan') && (
                                                <div>
                                                    <div className="flex items-center gap-2 mb-1">
                                                        <span className="bg-green-100 text-green-800 text-xs font-bold px-2 py-0.5 rounded border border-green-200">
                                                            {getRowLabel(3, betType)}
                                                        </span>
                                                    </div>
                                                    <div className="grid grid-cols-9 gap-1">
                                                        {Array.from({ length: horseCount }, (_, i) => i + 1).map(num => 
                                                            renderHorseButton(num, formation.third.includes(num), 'bg-green-500 border-green-600', () => toggleFormationHorse('third', num))
                                                        )}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>

                                {/* Add Button */}
                                <div className="p-4 bg-gray-50 border-t flex flex-col items-center">
                                    <div className="text-sm font-bold text-gray-700 mb-2">
                                        現在の選択: <span className="text-emerald-600 text-lg">{previewCombinations.length}</span> 点
                                    </div>
                                    <button
                                        onClick={addBetsToList}
                                        disabled={previewCombinations.length === 0}
                                        className={`w-full sm:w-auto px-8 py-3 rounded-full font-bold flex items-center justify-center gap-2 shadow-lg transition-transform active:scale-95 ${
                                            previewCombinations.length > 0 
                                                ? 'bg-emerald-600 text-white hover:bg-emerald-700' 
                                                : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                        }`}
                                    >
                                        <PlusCircle size={20} />
                                        下のリストに追加
                                    </button>
                                </div>
                            </section>

                            {/* Budget & Stats */}
                            {betList.length > 0 && (
                                <section className="bg-white rounded-lg shadow p-4 border-l-4 border-yellow-400">
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <div>
                                            <label className="block text-xs font-bold text-gray-500 uppercase mb-1">総予算</label>
                                            <div className="flex items-center gap-2">
                                                <input 
                                                    type="number" 
                                                    value={totalBudget}
                                                    onChange={(e) => setTotalBudget(parseInt(e.target.value) || 0)}
                                                    className="w-full border border-gray-300 rounded p-2 text-right font-mono text-lg focus:ring-2 focus:ring-emerald-500 outline-none"
                                                    step="100"
                                                />
                                                <span className="text-gray-500 text-sm">円</span>
                                            </div>
                                        </div>

                                        <div className="flex flex-col justify-between">
                                            <div className="flex justify-between text-sm mb-1">
                                                <span className="text-gray-600">買い目合計:</span>
                                                <span className="font-bold">{stats.count} 点</span>
                                            </div>
                                            <div className="flex justify-between text-sm mb-1">
                                                <span className="text-gray-600">投資総額:</span>
                                                <span className={`font-bold ${stats.totalStake > totalBudget ? 'text-red-500' : 'text-emerald-600'}`}>
                                                    {stats.totalStake.toLocaleString()} 円
                                                </span>
                                            </div>
                                            <div className="flex justify-between text-sm">
                                                <span className="text-gray-600">平均合成オッズ:</span>
                                                <span className="font-bold bg-gray-100 px-2 rounded">{stats.syntheticOdds} 倍</span>
                                            </div>
                                        </div>
                                    </div>

                                    <div className="mt-4 flex gap-2">
                                        <button 
                                            onClick={() => setAllocationMode('profit')}
                                            className={`flex-1 text-xs py-2 rounded border ${allocationMode === 'profit' ? 'bg-emerald-100 border-emerald-500 text-emerald-800 font-bold' : 'bg-white text-gray-600'}`}
                                        >
                                            払戻均等 (利益確保)
                                        </button>
                                        <button 
                                            onClick={() => setAllocationMode('flat')}
                                            className={`flex-1 text-xs py-2 rounded border ${allocationMode === 'flat' ? 'bg-emerald-100 border-emerald-500 text-emerald-800 font-bold' : 'bg-white text-gray-600'}`}
                                        >
                                            資金均等 (一律)
                                        </button>
                                    </div>
                                </section>
                            )}

                            {/* Bet List */}
                            {betList.length > 0 ? (
                                <section id="bet-list-section" className="bg-white rounded-lg shadow overflow-hidden">
                                    <div className="bg-gray-50 p-3 border-b flex justify-between items-center">
                                        <h3 className="font-bold text-gray-700 flex items-center gap-2">
                                            <Save size={18} /> 
                                            買い目リスト ({betList.length}点)
                                        </h3>
                                        <button onClick={fillMockOdds} className="text-xs flex items-center gap-1 text-emerald-600 hover:text-emerald-800">
                                            <RefreshCw size={12} /> オッズ自動入力(テスト)
                                        </button>
                                    </div>
                                    
                                    <div className="overflow-x-auto max-h-[600px]">
                                        <table className="w-full text-sm text-left relative">
                                            <thead className="bg-gray-100 text-gray-600 text-xs uppercase sticky top-0 z-10 shadow-sm">
                                                <tr>
                                                    <th className="p-3">式別 / 組合せ</th>
                                                    <th className="p-3 w-20">オッズ</th>
                                                    <th className="p-3 text-right">投資額</th>
                                                    <th className="p-3 text-right">予想払戻</th>
                                                    <th className="p-3 w-10"></th>
                                                </tr>
                                            </thead>
                                            <tbody className="divide-y divide-gray-100">
                                                {betList.map((bet) => {
                                                    const isWide = bet.type === 'wide';
                                                    const wideOdds = isWide ? oddsData[bet.key] : null;
                                                    const hasWideOdds = wideOdds && typeof wideOdds === 'object';
                                                    
                                                    const betData = calculatedData.find(row => row.key === bet.key);
                                                    
                                                    return (
                                                        <React.Fragment key={bet.key}>
                                                            <tr className="hover:bg-emerald-50 transition-colors">
                                                                <td className="p-3" rowSpan={isWide && hasWideOdds ? 2 : 1}>
                                                                    <div className="flex flex-col">
                                                                        <span className="text-[10px] text-gray-400 font-bold uppercase tracking-wider">
                                                                            {getTypeName(bet.type)}
                                                                        </span>
                                                                        <span className="font-mono font-bold text-gray-700 text-lg">
                                                                            {bet.label}
                                                                        </span>
                                                                    </div>
                                                                </td>
                                                                {isWide ? (
                                                                    <>
                                                                        <td className="p-3">
                                                                            <div className="flex items-center gap-1">
                                                                                <span className="text-xs text-gray-500 whitespace-nowrap">下限:</span>
                                                                                <input
                                                                                    type="number"
                                                                                    step="0.1"
                                                                                    placeholder="0.0"
                                                                                    value={hasWideOdds ? wideOdds.min || '' : ''}
                                                                                    onChange={(e) => handleOddsChange(bet.key, e.target.value, 'min')}
                                                                                    className="w-16 border border-gray-300 rounded px-1 py-1 text-right focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 outline-none"
                                                                                />
                                                                            </div>
                                                                        </td>
                                                                        <td className="p-3 text-right font-mono" rowSpan={2}>
                                                                            {betData?.stake > 0 ? (
                                                                                <span className="bg-emerald-100 text-emerald-800 px-2 py-1 rounded">
                                                                                    {betData.stake.toLocaleString()}
                                                                                </span>
                                                                            ) : '-'}
                                                                        </td>
                                                                        <td className="p-3 text-right">
                                                                            {betData?.stake > 0 && wideOdds.min ? (
                                                                                <div className="flex flex-col items-end">
                                                                                    <span className="font-bold">{Math.floor(betData.stake * wideOdds.min).toLocaleString()}</span>
                                                                                    <span className={`text-xs ${Math.floor(betData.stake * wideOdds.min) - stats.totalStake >= 0 ? 'text-emerald-600' : 'text-red-500'}`}>
                                                                                        {Math.floor(betData.stake * wideOdds.min) - stats.totalStake >= 0 ? '+' : ''}{(Math.floor(betData.stake * wideOdds.min) - stats.totalStake).toLocaleString()}
                                                                                    </span>
                                                                                </div>
                                                                            ) : '-'}
                                                                        </td>
                                                                    </>
                                                                ) : (
                                                                    <>
                                                                        <td className="p-3">
                                                                            <input
                                                                                type="number"
                                                                                step="0.1"
                                                                                placeholder="0.0"
                                                                                value={oddsData[bet.key] || ''}
                                                                                onChange={(e) => handleOddsChange(bet.key, e.target.value)}
                                                                                className="w-16 border border-gray-300 rounded px-1 py-1 text-right focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 outline-none"
                                                                            />
                                                                        </td>
                                                                        <td className="p-3 text-right font-mono">
                                                                            {betData?.stake > 0 ? (
                                                                                <span className="bg-emerald-100 text-emerald-800 px-2 py-1 rounded">
                                                                                    {betData.stake.toLocaleString()}
                                                                                </span>
                                                                            ) : '-'}
                                                                        </td>
                                                                        <td className="p-3 text-right">
                                                                            {betData?.stake > 0 ? (
                                                                                <div className="flex flex-col items-end">
                                                                                    <span className="font-bold">{betData.return.toLocaleString()}</span>
                                                                                    <span className={`text-xs ${betData.profit >= 0 ? 'text-emerald-600' : 'text-red-500'}`}>
                                                                                        {betData.profit >= 0 ? '+' : ''}{betData.profit.toLocaleString()}
                                                                                    </span>
                                                                                </div>
                                                                            ) : '-'}
                                                                        </td>
                                                                    </>
                                                                )}
                                                                <td className="p-3 text-right" rowSpan={isWide && hasWideOdds ? 2 : 1}>
                                                                    <button 
                                                                        onClick={() => removeBet(bet.key)}
                                                                        className="text-gray-400 hover:text-red-500 transition-colors"
                                                                    >
                                                                        <Trash2 size={16} />
                                                                    </button>
                                                                </td>
                                                            </tr>
                                                            {isWide && hasWideOdds && (
                                                                <tr className="hover:bg-emerald-50 transition-colors border-l-4 border-l-blue-200">
                                                                    <td className="p-3">
                                                                        <div className="flex items-center gap-1">
                                                                            <span className="text-xs text-gray-500 whitespace-nowrap">上限:</span>
                                                                            <input
                                                                                type="number"
                                                                                step="0.1"
                                                                                placeholder="0.0"
                                                                                value={wideOdds.max || ''}
                                                                                onChange={(e) => handleOddsChange(bet.key, e.target.value, 'max')}
                                                                                className="w-16 border border-gray-300 rounded px-1 py-1 text-right focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 outline-none"
                                                                            />
                                                                        </div>
                                                                    </td>
                                                                    <td className="p-3 text-right">
                                                                        {betData?.stake > 0 && wideOdds.max ? (
                                                                            <div className="flex flex-col items-end">
                                                                                <span className="font-bold">{Math.floor(betData.stake * wideOdds.max).toLocaleString()}</span>
                                                                                <span className={`text-xs ${Math.floor(betData.stake * wideOdds.max) - stats.totalStake >= 0 ? 'text-emerald-600' : 'text-red-500'}`}>
                                                                                    {Math.floor(betData.stake * wideOdds.max) - stats.totalStake >= 0 ? '+' : ''}{(Math.floor(betData.stake * wideOdds.max) - stats.totalStake).toLocaleString()}
                                                                                </span>
                                                                            </div>
                                                                        ) : '-'}
                                                                    </td>
                                                                </tr>
                                                            )}
                                                        </React.Fragment>
                                                    );
                                                })}
                                            </tbody>
                                        </table>
                                    </div>

                                    <div className="p-4 bg-gray-50 border-t">
                                        <button 
                                            onClick={saveToHistory}
                                            className="w-full bg-blue-600 text-white font-bold py-3 rounded-lg shadow hover:bg-blue-700 flex items-center justify-center gap-2"
                                        >
                                            <Save size={20} />
                                            履歴に保存する
                                        </button>
                                    </div>
                                </section>
                            ) : (
                                <div className="text-center py-12 text-gray-400 bg-white rounded-lg border-2 border-dashed border-gray-200">
                                    <Info className="mx-auto mb-2 opacity-50" />
                                    <p>まだ買い目がありません</p>
                                    <p className="text-xs mt-1">馬を選んで「下のリストに追加」を押してください</p>
                                </div>
                            )}
                        </main>
                    )}

                    {/* HISTORY VIEW */}
                    {currentView === 'history' && (
                        <main className="max-w-3xl mx-auto p-4 space-y-4">
                            <div className="flex items-center gap-2 mb-4">
                                <button 
                                    onClick={() => setCurrentView('calculator')}
                                    className="p-2 bg-white rounded-full shadow hover:bg-gray-100"
                                >
                                    <ArrowLeft size={20} className="text-gray-600" />
                                </button>
                                <h2 className="text-xl font-bold text-gray-700">保存済み履歴</h2>
                            </div>

                            {savedHistory.length === 0 ? (
                                <div className="text-center py-12 text-gray-400 bg-white rounded-lg">
                                    <History className="mx-auto mb-2 opacity-50" size={48} />
                                    <p>保存された履歴はありません</p>
                                </div>
                            ) : (
                                <div className="space-y-4">
                                    {savedHistory.map((entry) => {
                                        const betCount = entry.data.betList?.length || 0;
                                        const hasOdds = entry.data.oddsData && Object.keys(entry.data.oddsData).length > 0;
                                        
                                        return (
                                            <div key={entry.id} className="bg-white rounded-lg shadow p-4 border-l-4 border-blue-500">
                                                <div className="flex justify-between items-start mb-3">
                                                    <div className="flex-1">
                                                        <div className="flex items-center gap-2 mb-1">
                                                            <span className="font-bold text-lg text-gray-800">
                                                                {entry.meta.place} {entry.meta.raceNum}R
                                                            </span>
                                                            <span className="text-xs bg-gray-100 text-gray-600 px-2 py-0.5 rounded border">
                                                                {formatDate(entry.meta.date)}
                                                            </span>
                                                        </div>
                                                        {entry.meta.note && (
                                                            <p className="text-sm text-gray-500 flex items-center gap-1">
                                                                <FileText size={12} /> {entry.meta.note}
                                                            </p>
                                                        )}
                                                    </div>
                                                    <div className="text-right">
                                                        <span className="block text-xs text-gray-500">予算</span>
                                                        <span className="font-bold text-emerald-600">
                                                            {parseInt(entry.data.totalBudget).toLocaleString()}円
                                                        </span>
                                                    </div>
                                                </div>
                                                
                                                <div className="grid grid-cols-2 gap-2 text-xs mb-3">
                                                    <div className="bg-gray-50 p-2 rounded">
                                                        <span className="text-gray-500">買い目:</span>
                                                        <span className="font-bold ml-1">{betCount}点</span>
                                                    </div>
                                                    <div className="bg-gray-50 p-2 rounded">
                                                        <span className="text-gray-500">モード:</span>
                                                        <span className="font-bold ml-1">
                                                            {entry.data.allocationMode === 'profit' ? '払戻均等' : '資金均等'}
                                                        </span>
                                                    </div>
                                                </div>

                                                {hasOdds && (
                                                    <div className="text-xs text-blue-600 bg-blue-50 p-2 rounded mb-3">
                                                        ✓ オッズデータ保存済み
                                                    </div>
                                                )}

                                                <div className="flex gap-2">
                                                    <button 
                                                        onClick={() => loadFromHistory(entry)}
                                                        className="flex-1 bg-emerald-600 text-white py-2 rounded text-sm font-bold hover:bg-emerald-700 flex items-center justify-center gap-1"
                                                    >
                                                        <RefreshCw size={14} />
                                                        読み込む
                                                    </button>
                                                    <button 
                                                        onClick={() => deleteHistoryItem(entry.id)}
                                                        className="px-3 bg-white border border-gray-300 text-gray-500 rounded hover:bg-red-50 hover:text-red-500 hover:border-red-300"
                                                    >
                                                        <Trash2 size={16} />
                                                    </button>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            )}
                        </main>
                    )}
                </div>
            );
        };

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<HorseRacingOddsManager />);
        
        // Initialize lucide icons after render
        setTimeout(() => {
            if (window.lucide) {
                window.lucide.createIcons();
            }
        }, 100);
    </script>
</body>
</html>
